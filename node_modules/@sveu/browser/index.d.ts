import * as svelte_store from 'svelte/store';
import { Readable } from 'svelte/store';
import { IntervalFnOptions, AnyFn, ConfigurableEventFilter, Fn, AsyncStateOptions, Pauseable, Watchable, Dict } from '@sveu/shared';
import * as _sveu_shared_types_8a2f2352 from '@sveu/shared/types-8a2f2352';

/**
 * Reactive `document.activeElement`
 *
 * @example
 * ```ts
 * const activeElement = activeEl()
 * $: console.log($activeElement)
 * ```
 *
 * @returns A readable store with the current active element.
 */
declare function activeEl<T extends HTMLElement>(): {
    subscribe: (this: void, run: svelte_store.Subscriber<T | null>, invalidate?: svelte_store.Invalidator<T | null> | undefined) => svelte_store.Unsubscriber;
};

interface MemoryInfo {
    /**
     * The maximum size of the heap, in bytes, that is available to the context.
     */
    jsHeapSizeLimit: number;
    /**
     *  The total allocated heap size, in bytes.
     */
    totalJSHeapSize: number;
    /**
     * The currently active segment of JS heap, in bytes.
     */
    usedJSHeapSize: number;
}
interface MemoryOptions extends IntervalFnOptions {
    /** The interval in seconds to check the memory. */
    interval?: number;
}
type PerformanceMemory = Performance & {
    memory: MemoryInfo;
};
interface FaviconOptions {
    /** The base url to prepend to the favicon. */
    base_url?: string;
    /** The rel attribute of the favicon. */
    rel?: string;
}
interface InferEventTarget<Events> {
    addEventListener(event: Events, fn?: AnyFn, options?: any): any;
    removeEventListener(event: Events, fn?: AnyFn, options?: any): any;
}
interface GeneralEventListener<E = Event> {
    (evt: E): void;
}
type ListAble<T> = T[] | T;
interface BroadcastChannelOptions {
    /**
     * The name of the channel.
     * @defaultValue "default"
     */
    name?: string;
}
interface PushOptions {
    /**
     * Convert the push object into a base64 string
     *
     * @defaultValue true
     */
    base64?: boolean;
    /**
     * Start subscribing, when the user is visible
     *
     * @defaultValue true
     */
    userVisibleOnly?: boolean;
}
type DescriptorNamePolyfill = "accelerometer" | "accessibility-events" | "ambient-light-sensor" | "background-sync" | "camera" | "clipboard-read" | "clipboard-write" | "gyroscope" | "magnetometer" | "microphone" | "notifications" | "payment-handler" | "persistent-storage" | "push" | "speaker";
type GeneralPermissionDescriptor = PermissionDescriptor | {
    name: DescriptorNamePolyfill;
};
interface PermissionOptions<Controls extends boolean> {
    /**
     * Expose more controls
     *
     * @defaultValue false
     */
    controls?: Controls;
}
type PermissionReturn = Readable<PermissionState | undefined>;
interface PermissionReturnWithControls {
    /** The permission state. */
    state: PermissionReturn;
    /** Whether the permission is supported. */
    supported: Readable<boolean>;
    /** Query the permission state. */
    query: () => Promise<PermissionStatus | undefined>;
}
interface ClipboardOptions<Source> {
    /**
     * Enabled reading for clipboard
     *
     * @defaultValue false
     */
    read?: boolean;
    /**
     * Copy source
     */
    source?: Source;
    /**
     * Seconds to reset state of `copied` ref
     *
     * @defaultValue 1.5
     */
    copiedDuring?: number;
    /**
     * Whether fallback to document.execCommand('copy') if clipboard is undefined.
     *
     * @defaultValue false
     */
    legacy?: boolean;
}
interface ClipboardReturn<Optional> {
    /** Returns whether the clipboard is supported. */
    supported: Readable<boolean>;
    /** The text in the clipboard. */
    text: Readable<string>;
    /** Whether the text is copied. */
    copied: Readable<boolean>;
    /** A function to copy the text to the clipboard. */
    copy: Optional extends true ? (text?: string) => Promise<void> : (text: string) => Promise<void>;
}
interface FileDialogOptions {
    /**
     * Allowed multiple files selection.
     *
     * @defaultValue true
     */
    multiple?: boolean;
    /**
     * Allowed file types.
     *
     * @defaultValue '*'
     */
    accept?: string;
    /**
     * Select the input source for the capture file.
     *
     * @see [HTMLInputElement Capture](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/capture)
     */
    capture?: string;
    /**
     * Reset when open file dialog.
     *
     * @defaultValue true
     * */
    reset?: boolean;
}
type NetworkType = "bluetooth" | "cellular" | "ethernet" | "none" | "wifi" | "wimax" | "other" | "unknown";
type NetworkEffectiveType = "slow-2g" | "2g" | "3g" | "4g" | undefined;
interface RafFnOptions {
    /**
     * Start the requestAnimationFrame loop immediately on creation
     *
     * @defaultValue true
     */
    immediate?: boolean;
}
interface FpsOptions {
    /**
     * Calculate the FPS on every x frames.
     * @defaultValue 10
     */
    every?: number;
}
type Breakpoints<K extends string = string> = Record<K, number | string>;
interface EyeDropperOpenOptions {
    /**
     * The signal to abort the eye dropper.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal
     */
    signal?: AbortSignal;
}
interface EyeDropper {
    new (): EyeDropper;
    open: (options?: EyeDropperOpenOptions) => Promise<{
        sRGBHex: string;
    }>;
    [Symbol.toStringTag]: "EyeDropper";
}
interface EyeDropperOptions {
    /**
     * A fallback value to use when the eye dropper is not supported.
     *
     * @defaultValue ''
     */
    fallback?: string;
}
interface GeolocationOptions {
    /** Whether to enable high accuracy.
     *
     * @defaultValue true
     */
    high?: boolean;
    /** The maximum age of a cached position in seconds.
     *
     * @defaultValue 3
     */
    maxAge?: number;
    /** The timeout in seconds.
     *
     * @defaultValue 27
     */
    timeout?: number;
    /**
     * To start the geolocation immediately
     *
     * @defaultValue true
     */
    immediate?: boolean;
}
interface ImageOptions {
    /** Address of the resource */
    src: string;
    /** Images to use in different situations, e.g., high-resolution displays, small monitors, etc. */
    srcset?: string;
    /** Image sizes for different page layouts */
    sizes?: string;
    /** Image alternative information */
    alt?: string;
    /** Image classes */
    class?: string;
    /** Image loading */
    loading?: HTMLImageElement["loading"];
    /** Image CORS settings */
    crossOrigin?: string;
    /** Referrer policy for fetch https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy */
    referrerPolicy?: HTMLImageElement["referrerPolicy"];
}
interface IntersectionObserverOptions {
    /**
     * The Element or Document whose bounds are used as the bounding box when testing for intersection.
     */
    root?: HTMLElement | SVGElement | undefined | null;
    /**
     * A string which specifies a set of offsets to add to the root's bounding_box when calculating intersections.
     *
     * @defaultValue "0px"
     */
    margin?: string;
    /**
     * Either a single number or an array of numbers between 0.0 and 1.
     *
     * @defaultValue 0.1
     */
    threshold?: number | number[];
}
interface Position {
    x: number;
    y: number;
}
type UseMouseCoordType = "page" | "client" | "screen" | "movement";
type UseMouseSourceType = "mouse" | "touch" | null;
type UseMouseEventExtractor = (event: MouseEvent | Touch) => [x: number, y: number] | null | undefined;
interface MouseOptions extends ConfigurableEventFilter {
    /**
     * Mouse position based by page, client, screen or relative to previous position
     *
     * @defaultValue 'page'
     */
    type?: UseMouseCoordType | UseMouseEventExtractor;
    /**
     * Listen to `touchmove` events
     *
     * @defaultValue true
     */
    touch?: boolean;
    /**
     * Reset to initial value when `touchend` event fired
     *
     * @defaultValue false
     */
    resetOnTouchEnds?: boolean;
    /**
     * The fallback position when the browser doesn't support mouse events
     */
    fallback?: Position;
}
type MouseSourceType = "mouse" | "touch" | null;
interface WebNotificationOptions extends NotificationOptions {
    /**
     * The title read-only property of the Notification interface indicates
     * the title of the notification
     *
     * @defaultValue ''
     */
    title?: string;
}
type WakeLockType = "screen";
interface WakeLockSentinel extends EventTarget {
    type: WakeLockType;
    released: boolean;
    release: () => Promise<void>;
}
type NavigatorWithWakeLock = Navigator & {
    wakeLock: {
        request: (type: WakeLockType) => Promise<WakeLockSentinel>;
    };
};
interface WindowSizeOptions {
    /** Initial width */
    initialWidth?: number;
    /** Initial height */
    initialHeight?: number;
    /**
     * Listen to window `orientationchange` event
     *
     * @defaultValue true
     */
    orientation?: boolean;
    /**
     * Whether the scrollbar should be included in the width and height
     * @defaultValue true
     */
    scrollbar?: boolean;
}
type WorkerFn = (...args: unknown[]) => Worker;
interface WebWorkerReturn<T = any> {
    /**
     * The message event
     */
    data: Readable<T>;
    /**
     * The error event
     *
     */
    error: Readable<T>;
    /**
     * Post a message to the worker
     */
    post: (typeof Worker.prototype)["postMessage"];
    /**
     * Cleanup the worker
     */
    cleanup: () => void;
    /**
     * The worker instance
     */
    wk: Readable<Worker | undefined>;
}
type WebSocketStatus = "OPEN" | "CONNECTING" | "CLOSED";
interface WebSocketOptions {
    /**
     * Hook when the websocket is connected
     */
    onConnected?: (ws: WebSocket) => void;
    /**
     * Hook when the websocket is disconnected
     */
    onDisconnected?: (ws: WebSocket, event: CloseEvent) => void;
    /**
     * Hook when the websocket is closed
     */
    onError?: (ws: WebSocket, event: Event) => void;
    /**
     * Hook when the websocket received a message
     */
    onMessage?: (ws: WebSocket, event: MessageEvent) => void;
    /**
     * Send heartbeat for every x seconds passed
     *
     * @defaultValue false
     */
    heartbeat?: boolean | {
        /**
         * Message for the heartbeat
         *
         * @defaultValue 'ping'
         */
        message?: string | ArrayBuffer | Blob;
        /**
         * Interval, in seconds
         *
         * @defaultValue 1
         */
        interval?: number;
        /**
         * Heartbeat response timeout, in seconds
         *
         * @defaultValue 1
         */
        pongTimeout?: number;
    };
    /**
     * Enabled auto reconnect
     *
     * @defaultValue false
     */
    autoReconnect?: boolean | {
        /**
         * Maximum retry times.
         *
         * Or you can pass a predicate function (which returns true if you want to retry).
         *
         * @defaultValue -1
         */
        retries?: number | (() => boolean);
        /**
         * Delay for reconnect, in seconds
         *
         * @defaultValue 1
         */
        delay?: number;
        /**
         * On maximum retry times reached.
         */
        onFailed?: Fn;
    };
    /**
     * Automatically open a connection
     *
     * @defaultValue true
     */
    immediate?: boolean;
    /**
     * Automatically close a connection
     *
     * @defaultValue true
     */
    autoClose?: boolean;
    /**
     * List of one or more sub-protocol strings
     *
     * @defaultValue []
     */
    protocols?: string[];
}
interface VibrateOptions {
    /**
     *
     * Vibration Pattern
     *
     * An array of values describes alternating periods in which the
     * device is vibrating and not vibrating. Each value in the array
     * is converted to an integer, then interpreted alternately as
     * the number of milliseconds the device should vibrate and the
     * number of seconds it should not be vibrating
     *
     * @defaultValue []
     *
     */
    pattern?: number[] | number;
    /**
     * Interval to run a persistent vibration, in seconds
     *
     * Pass `0` to disable
     *
     * @defaultValue 0
     *
     */
    interval?: number;
}
interface PerformanceObserverOptions extends PerformanceObserverInit {
    /**
     * Start the observer immediate.
     *
     * @defaultValue true
     */
    immediate?: boolean;
}
interface UrlQueryOptions<T> {
    /**
     * Remove `null` and `undefined` values from the query object
     *
     * @defaultValue true
     */
    removeNullish?: boolean;
    /**
     * Remove `false` values from the query object
     *
     * @defaultValue false
     */
    removeFalsy?: boolean;
    /** A fallback value to use when the query is empty */
    fallback?: T;
    /**
     * Write back to `window.history` automatically
     *
     * @defaultValue true
     */
    write?: boolean;
    /**
     * Encode the query string using `encodeURIComponent`
     *
     * @defaultValue false
     */
    encode?: boolean;
}
interface StorageSerializer<T> {
    read(raw: string): T;
    write(value: T): string;
}
interface StorageOptions<T> {
    /**
     * Where to store the data
     *
     * @defaultValue "local"
     *
     */
    store?: "local" | "session" | "cookie" | "url";
    /**
     * Called when an error occurs
     *
     * @param error - Error
     *
     */
    onError?: (error: unknown) => void;
    /**
     * Custom data serialization
     */
    serializer?: StorageSerializer<T>;
    /**
     * Sync data between tabs. Only works with `store: "local"`
     *
     * @defaultValue true
     */
    sync?: boolean;
}
type KeyPredicate = (event: KeyboardEvent) => boolean;
type KeyFilter = true | string | string[] | KeyPredicate;
type KeyStrokeEvents = "keydown" | "keypress" | "keyup";
interface OnKeyStrokeOptions {
    /**
     * The key(s) to listen to.
     */
    event?: KeyStrokeEvents;
    /**
     * The target element to listen to.
     */
    target?: EventTarget | null | undefined;
    passive?: boolean;
    /**
     * Set to `true` to ignore repeated events when the key is being held down.
     *
     * @defaultValue false
     */
    dedupe?: boolean;
}
interface ToDataURLOptions {
    /**
     * MIME type
     */
    type?: string | undefined;
    /**
     * Image quality of jpeg or webp
     */
    quality?: any;
}
interface Base64ObjectOptions<T> {
    serializer: (v: T) => string;
}

/**
 * Convert a value to a base64 string
 *
 * @param target - The value to convert
 *
 * @param options - The options to use
 * - `serializer` - The serializer to use. Only used if the target is an object
 * - `type` - The MIME type to use. Only used if the target is a canvas or image
 * - `quality` - The image quality to use. Only used if the target is a canvas or image
 *
 * @example
 * ```ts
 * const result = base64('Hello world')
 * ```
 *
 * @example
 * ```ts
 * const result = base64(new Blob(['Hello world']))
 * ```
 *
 * @example
 * ```ts
 * const result = base64(new ArrayBuffer(10))
 * ```
 *
 * @returns The base64 string readable store
 */
declare function base64$1(target: string): Readable<string>;
declare function base64$1(target: Blob): Readable<string>;
declare function base64$1(target: ArrayBuffer): Readable<string>;
declare function base64$1(target: HTMLCanvasElement, options?: ToDataURLOptions): Readable<string>;
declare function base64$1(target: HTMLImageElement, options?: ToDataURLOptions): Readable<string>;
declare function base64$1<T extends Record<string, unknown>>(target: T, options?: Base64ObjectOptions<T>): Readable<string>;
declare function base64$1<T extends Map<string, unknown>>(target: T, options?: Base64ObjectOptions<T>): Readable<string>;
declare function base64$1<T extends Set<unknown>>(target: T, options?: Base64ObjectOptions<T>): Readable<string>;
declare function base64$1<T>(target: T[], options?: Base64ObjectOptions<T[]>): Readable<string>;

/**
 * Reactively viewport breakpoints
 *
 * @param breakpoints - Key value pairs of breakpoints
 *
 * @example
 * ```ts
 * const { gt, gte, lt, lte, bn, xs, sm, md, lg, xl } = breakpoints({
 *  xs: 0,
 *  sm: 576,
 *  md: 768,
 *  lg: 992,
 *  xl: 1200,
 * })
 * ```
 * @returns
 * - `gt` - Checks if the viewport is greater than the breakpoint
 * - `gte` - Checks if the viewport is greater than or equal to the breakpoint
 * - `lt` - Checks if the viewport is smaller than the breakpoint
 * - `lte` - Checks if the viewport is smaller than or equal to the breakpoint
 * - `bn` - Checks if the viewport is between the two breakpoints
 * - `shortcuts` - Shortcut methods for each breakpoint
 */
declare function breakpoints<K extends string>(breakpoints: Breakpoints<K>): {
    gt: (key: K) => Readable<boolean>;
    gte: (key: K) => Readable<boolean>;
    lt: (key: K) => Readable<boolean>;
    lte: (key: K) => Readable<boolean>;
    bn: (a: K, b: K) => Readable<boolean>;
} & Record<K, Readable<boolean>>;

/**
 * Reactive BroadcastChannel
 *
 * @param options - The options for the BroadcastChannel.
 * - `name` - The name of the channel. default: `default`
 *
 * @example
 * ```ts
 * const { supported, channel, data, post, close, error, closed } = broadcastChannel()
 * ```
 *
 * @returns
 * - `supported` - Is the BroadcastChannel supported.
 * - `channel` - The BroadcastChannel instance.
 * - `data` - The data from the channel.
 * - `post` - Send data to the channel.
 * - `close` - Close the channel.
 * - `error` - The error from the channel.
 * - `closed` - Is the channel closed.
 */
declare function broadcastChannel(options?: BroadcastChannelOptions): {
    channel: svelte_store.Readable<BroadcastChannel | undefined>;
    closed: svelte_store.Readable<boolean>;
    data: svelte_store.Readable<unknown>;
    error: svelte_store.Readable<Event | null>;
    supported: svelte_store.Readable<boolean>;
    close: () => void;
    post: (data: unknown) => void;
};

/**
 * Reactive Clipboard API.
 *
 * @param options - The options for the clipboard.
 * - `read` - Enabled reading for clipboard. default: `false`
 * - `source` - Copy source.
 * - `copiedDuring` - Seconds to reset state of `copied` ref. default: `1.5`
 * - `legacy` - Whether fallback to document.execCommand('copy') if clipboard is undefined. default: `false`
 *
 * @example
 * ```ts
 * const { supported, text, copied, copy } = clipboard()
 * ```
 *
 * @returns
 * - `supported` - Returns whether the clipboard is supported.
 * - `text` - The text in the clipboard.
 * - `copied` - Whether the text is copied.
 * - `copy` - A function to copy the text to the clipboard.
 */
declare function clipboard(options?: ClipboardOptions<undefined>): ClipboardReturn<false>;
declare function clipboard(options: ClipboardOptions<string>): ClipboardReturn<true>;

/**
 * Reactive `document.visibilityState`
 *
 * @example
 * ```ts
 * const visible = domVisible()
 * ```
 *
 * @returns A readable store with the current visibility state.
 */
declare function domVisible(): Readable<DocumentVisibilityState>;

/**
 * Create a function that dispatches a custom event.
 *
 * @param target - The element to dispatch the event on.
 *
 * @example
 * ```ts
 * const dispatch = eventDispatcher(document.body)
 *
 * dispatch("my-event", "my-value")
 * ```
 * @returns The function to dispatch the event.
 */
declare function eventDispatcher(target: HTMLElement | SVGElement | null | undefined): <T>(name: string, value: T) => void;

/**
 * Register using addEventListener on mounted, and removeEventListener automatically on destroy.
 *
 * Overload 1: Omitted Window target.
 *
 * @param event - The event name.
 *
 * @param listener - The event listener.
 *
 * @param options - The event listener options.
 *
 * @example
 * ```ts
 * const listener = () => {}
 * on('click', listener)
 * ```
 *
 * @example
 * ```ts
 * const listener = () => {}
 * on(window, 'click', listener)
 * ```
 *
 * @example
 * ```ts
 * const listener = () => {}
 * on(document, 'click', listener)
 * ```
 *
 * @example
 * ```ts
 * let target
 * const listener = () => {}
 * on(target, 'click', listener)
 * ```
 *
 * @returns The cleanup function.
 */
declare function eventListener<E extends keyof WindowEventMap>(event: ListAble<E>, listener: ListAble<(this: Window, ev: WindowEventMap[E]) => any>, options?: boolean | AddEventListenerOptions): Fn;
/**
 * Register using addEventListener on mounted, and removeEventListener automatically on destroy.
 *
 * Overload 2: Explicitly Window target
 *
 * @param target - The window target.
 *
 * @param event - The event name.
 *
 * @param listener - The event listener.
 *
 * @param options - The event listener options.
 *
 * @example
 * ```ts
 * const listener = () => {}
 * on('click', listener)
 * ```
 *
 * @example
 * ```ts
 * const listener = () => {}
 * on(window, 'click', listener)
 * ```
 *
 * @example
 * ```ts
 * const listener = () => {}
 * on(document, 'click', listener)
 * ```
 *
 * @example
 * ```ts
 * let target
 * const listener = () => {}
 * on(target, 'click', listener)
 * ```
 *
 * @returns The cleanup function.
 */
declare function eventListener<E extends keyof WindowEventMap>(target: Window, event: ListAble<E>, listener: ListAble<(this: Window, ev: WindowEventMap[E]) => any>, options?: boolean | AddEventListenerOptions): Fn;
/**
 * Register using addEventListener on mounted, and removeEventListener automatically on destroy.
 *
 * Overload 3: Explicitly Document target
 *
 * @param target - The document target.
 *
 * @param event - The event name.
 *
 * @param listener - The event listener.
 *
 * @param options - The event listener options.
 *
 * @example
 * ```ts
 * const listener = () => {}
 * on('click', listener)
 * ```
 *
 * @example
 * ```ts
 * const listener = () => {}
 * on(window, 'click', listener)
 * ```
 *
 * @example
 * ```ts
 * const listener = () => {}
 * on(document, 'click', listener)
 * ```
 *
 * @example
 * ```ts
 * let target
 * const listener = () => {}
 * on(target, 'click', listener)
 * ```
 *
 * @returns The cleanup function.
 */
declare function eventListener<E extends keyof DocumentEventMap>(target: Document, event: ListAble<E>, listener: ListAble<(this: Window, ev: DocumentEventMap[E]) => any>, options?: boolean | AddEventListenerOptions): Fn;
/**
 * Register using addEventListener on mounted, and removeEventListener automatically on destroy.
 *
 * Overload 4: Custom event target with event type infer
 *
 * @param target - The event target.
 *
 * @param event - The event name.
 *
 * @param listener - The event listener.
 *
 * @param options - The event listener options.
 *
 * @example
 * ```ts
 * const listener = () => {}
 * on('click', listener)
 * ```
 *
 * @example
 * ```ts
 * const listener = () => {}
 * on(window, 'click', listener)
 * ```
 *
 * @example
 * ```ts
 * const listener = () => {}
 * on(document, 'click', listener)
 * ```
 *
 * @example
 * ```ts
 * let target
 * const listener = () => {}
 * on(target, 'click', listener)
 * ```
 *
 * @returns The cleanup function.
 */
declare function eventListener<Names extends string, EventType = Event>(target: InferEventTarget<Names>, event: ListAble<Names>, listener: ListAble<GeneralEventListener<EventType>>, options?: boolean | AddEventListenerOptions): Fn;
/**
 * Register using addEventListener on mounted, and removeEventListener automatically on destroy.
 *
 * Overload 5: Custom event target fallback
 *
 * @param target - The event target.
 *
 * @param event - The event name.
 *
 * @param listener - The event listener.
 *
 * @param options - The event listener options.
 *
 * @example
 * ```ts
 * const listener = () => {}
 * on('click', listener)
 * ```
 *
 * @example
 * ```ts
 * const listener = () => {}
 * on(window, 'click', listener)
 * ```
 *
 * @example
 * ```ts
 * const listener = () => {}
 * on(document, 'click', listener)
 * ```
 *
 * @example
 * ```ts
 * let target
 * const listener = () => {}
 * on(target, 'click', listener)
 * ```
 *
 * @returns The cleanup function.
 */
declare function eventListener<EventType = Event>(target: EventTarget | null | undefined, event: ListAble<string>, listener: ListAble<GeneralEventListener<EventType>>, options?: boolean | AddEventListenerOptions): Fn;

/**
 * Reactive [EyeDropper API](https://developer.mozilla.org/en-US/docs/Web/API/EyeDropper_API)
 *
 * @param options - Options
 * - `fallback` - The fallback value
 *
 * @example
 * ```ts
 * const { supported, result, open } = eyeDropper()
 * ```
 *
 * @returns - The eye dropper
 * - `supported` - Whether the browser supports the EyeDropper API
 * - `result` - The sRGBHex of the selected color
 * - `open` - Open the eye dropper
 *
 */
declare function eyeDropper(options?: EyeDropperOptions): {
    supported: svelte_store.Readable<boolean>;
    result: svelte_store.Readable<string>;
    open: (openOptions?: EyeDropperOpenOptions) => Promise<{
        sRGBHex: string;
    } | undefined>;
};

/**
 * Open file dialog with ease.
 *
 * @param options - Options
 * - `multiple` - Allowed multiple files selection.
 * - `accept` - Allowed file types.
 * - `capture` - Capture mode.
 *
 * @example
 * ```ts
 * const { files, accepted, rejected, open, reset, onChange } = fileDialog()
 * ```
 * @example
 * ```ts
 * const { files, accepted, rejected, open, reset, onChange } = fileDialog({
 * 	multiple: false,
 * 	accept: "image/*",
 * 	capture: "user",
 *  reset: true,
 * })
 * ```
 *
 * @returns
 * - `files` - The files selected.
 * - `accepted` - The files accepted.
 * - `rejected` - The files rejected.
 * - `open` - Open file dialog.
 * - `reset` - Reset file dialog.
 * - `onChange` - The event when the files change.
 */
declare function fileDialog(options?: FileDialogOptions): {
    files: svelte_store.Readable<FileList | null>;
    accepted: svelte_store.Readable<File[] | null>;
    rejected: svelte_store.Readable<File[] | null>;
    open: (localOptions?: Partial<FileDialogOptions>) => void;
    reset: () => void;
    onChange: _sveu_shared_types_8a2f2352.t<any>;
};

/**
 * Reactive FPS (frames per second)
 *
 * @param options - Options
 * - `every` - Calculate the FPS on every x frames. Default: `10`
 *
 * @example
 * ```ts
 * const fps = fps()
 * ```
 *
 * @example
 * ```ts
 * const fps = fps({ every: 60 })
 * ```
 *
 * @returns Readable store
 */
declare function fps(options?: FpsOptions): {
    subscribe: (this: void, run: svelte_store.Subscriber<number>, invalidate?: svelte_store.Invalidator<number> | undefined) => svelte_store.Unsubscriber;
};

/**
 * Reactive Geolocation API.
 *
 * @param options
 * - `high` Whether to enable high accuracy. Defaults to `true`.
 * - `maxAge` The maximum age of a cached position in seconds. Defaults to `3`.
 * - `timeout` The timeout in seconds. Defaults to `27`.
 * - `immediate` Whether to start watching the location immediately. Defaults to `true`.
 *
 * @example
 * ```ts
 * const { supported, coords, locatedAt, error, resume, pause } = geolocation()
 * ```
 *
 * @returns
 * - `supported` Whether the Geolocation API is supported.
 * - `coords` The current coordinates.
 * - `locatedAt` The timestamp of the last location update.
 * - `error` The last error.
 * - `resume` Resume watching the location.
 * - `pause` Pause watching the location.
 */
declare function geolocation(options?: GeolocationOptions): {
    supported: svelte_store.Readable<boolean>;
    coords: svelte_store.Readable<GeolocationCoordinates>;
    locatedAt: svelte_store.Readable<number | null>;
    error: svelte_store.Readable<GeolocationPositionError | null>;
    resume: () => void;
    pause: () => void;
};

/**
 * Reactive load an image in the browser, you can wait the result to display it or show a fallback.
 *
 * @param options
 * - `src` - Address of the resource.
 * - `srcset` - Images to use in different situations, e.g., high-resolution displays, small monitors, etc.
 * - `sizes` - Image sizes for different page layouts.
 * - `alt` - Alternative text.
 * - `class` - Image class
 * - `loading` - Image loading
 * - `crossOrigin` - Image crossOrigin
 * - `referrerPolicy` - Image referrerPolicy
 *
 * @param asyncStateOptions - see [Async state options](https://svelte-u.vercel.app/docs/shared/asyncState/#options)
 *
 * @example
 * ```ts
 * const { loading } = image({
 * 	src: "https://picsum.photos/200/300",
 * 	alt: "Random image",
 * })
 * ```
 *
 * @returns An async state. See [Async state](https://svelte-u.vercel.app/docs/shared/asyncState/#returns)
 */
declare function image(options: ImageOptions, asyncStateOptions?: AsyncStateOptions): {
    state: svelte_store.Readable<HTMLImageElement | undefined>;
    ready: svelte_store.Readable<boolean>;
    loading: svelte_store.Readable<boolean>;
    error: svelte_store.Readable<unknown>;
    execute: (delay?: number | undefined, ...args: any[]) => Promise<HTMLImageElement | undefined>;
};

/**
 * Wrapper for the IntersectionObserver API.
 *
 * @param target - The target element to observe.
 *
 * @param fn - The function to call when the target element is intersecting.
 *
 * @param options - The options to pass to the IntersectionObserver.
 * - `root` - The Element or Document whose bounds are used as the bounding box when testing for intersection.
 * - `margin` - A string which specifies a set of offsets to add to the root's bounding_box when calculating intersections. Defaults to `"0px"`.
 * - `threshold` - Either a single number or an array of numbers between 0.0 and 1. Defaults to `0.1`.
 *
 * @example
 * ```ts
 * const { supported, stop } = intersectionObserver(
 * 	document.querySelector("#target"),
 * 	(entries) => {
 * 		entries.forEach((entry) => {
 * 			if (entry.isIntersecting) {
 * 				// Do something
 * 			}
 * 		})
 * 	},
 * 	{
 * 		root: document.querySelector("#root"),
 * 		margin: "10px",
 * 		threshold: [0, 0.25, 0.5, 0.75, 1],
 * 	}
 * )
 * ```
 *
 * @returns
 * - `supported` - Whether the IntersectionObserver API is supported.
 * - `stop` - Stop the IntersectionObserver.
 *
 */
declare function intersectionObserver(target: HTMLElement | SVGElement | null | undefined, fn: IntersectionObserverCallback, options?: IntersectionObserverOptions): {
    supported: svelte_store.Readable<boolean>;
    stop: () => void;
} | undefined;

/**
 * Reactive Media Query.
 *
 * @param query - Media Query
 *
 * @example
 * ```ts
 * const { subscribe } = mediaQuery("(min-width: 768px)")
 * ```
 *
 * @returns Readable Store
 *
 */
declare function mediaQuery(query: string): svelte_store.Readable<boolean>;

/**
 * Reactive Memory Info.
 *
 * @param options - Options to use:
 * - `interval` - The interval in seconds to check the memory.
 * - `IntervalFnOptions` - Options from `intervalfn`.
 *
 * @example
 * ```ts
 * const { supported, result } = memory()
 * ```
 *
 * @returns
 * - `supported` - If the browser supports the `memory` API.
 * - `result` - A readable store with the memory info.
 *
 */
declare function memory(options?: MemoryOptions): {
    supported: svelte_store.Readable<boolean>;
    result: svelte_store.Readable<MemoryInfo | undefined>;
};

/**
 * Reactive mouse position.
 *
 * @param options - The options for the mouse.
 * - `type` - The type of the mouse position. Either `page` or `client` or `movement`, etc. Default is `page`.
 * - `touch` - Whether to listen to `touchmove` events. Default is `true`.
 * - `resetOnTouchEnds` - Whether to reset to the initial value when `touchend` event fired. Default is `false`.
 * - `fallback` - The fallback position when the browser doesn't support mouse events.
 * - `eventFilter` - The event filter.
 *
 * @example
 * ```ts
 * const { x, y, type } = mouse()
 * ```
 *
 * @returns
 * - `x` - The x position.
 * - `y` - The y position.
 * - `type` - The source type of the mouse position.
 *
 */
declare function mouse(options?: MouseOptions): {
    x: svelte_store.Readable<number>;
    y: svelte_store.Readable<number>;
    type: svelte_store.Readable<MouseSourceType>;
};

/**
 * Watch for changes being made to the DOM tree.
 *
 * @param target - The target node on which to observe DOM mutations.
 *
 * @param fn - The function to call when a mutation occurs.
 *
 * @param options - [See MutationObserver Options](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe)
 *
 * @example
 * ```ts
 * const { supported, cleanup } = mutationObserver(document.body, () => {
 * 	console.log("DOM changed!")
 * })
 * ```
 *
 * @returns
 * - `supported` - Whether the browser supports the `MutationObserver` API.
 * - `cleanup` - A function to stop watching for changes.
 */
declare function mutationObserver(target: HTMLElement | SVGElement | undefined | null, fn: MutationCallback, options?: MutationObserverInit): {
    supported: svelte_store.Readable<boolean>;
    cleanup: () => void;
};

/**
 * Reactive Network status.
 *
 * @example
 * ```ts
 * const { supported, online} = network()
 * ```
 *
 * @returns
 * - `supported` - Whether the browser supports the Network Information API.
 * - `online` - Whether the device is online.
 * - `saveData` - Whether the device is in a "save data" mode.
 * - `offlineAt` - The timestamp of when the device went offline.
 * - `onlineAt` - The timestamp of when the device went online.
 * - `downlink` - The effective bandwidth estimate in megabits per second, rounded to the nearest multiple of 25 kilobits per second.
 * - `downlinkMax` - The maximum downlink speed of the underlying connection technology in megabits per second, rounded to the nearest multiple of 25 kilobits per second.
 * - `effectiveType` - The effective type of the connection meaning one of 'slow-2g', '2g', '3g', or '4g'.
 * - `rtt` - The estimated effective round-trip time of the current connection.
 * - `type` - The type of connection meaning one of 'bluetooth', 'cellular', 'ethernet', 'none', 'wifi', 'wimax', 'other', or 'unknown'.
 *
 */
declare function network(): {
    supported: svelte_store.Readable<boolean>;
    online: svelte_store.Readable<boolean>;
    saveData: svelte_store.Readable<boolean>;
    offlineAt: svelte_store.Readable<number | undefined>;
    onlineAt: svelte_store.Readable<number | undefined>;
    downlink: svelte_store.Readable<number | undefined>;
    downlinkMax: svelte_store.Readable<number | undefined>;
    effectiveType: svelte_store.Readable<NetworkEffectiveType>;
    rtt: svelte_store.Readable<number | undefined>;
    type: svelte_store.Readable<NetworkType>;
};

/**
 * Reactive notification
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/notification
 * @param options - options
 *
 * @example
 * ```ts
 * const { supported, notify, show, close, onClick, onShow, onError, onClose } = notification()
 * ```
 *
 * @returns
 * - `supported` - Whether the browser supports the Notification API.
 * - `notify` - The notification instance.
 * - `show` - Show the notification.
 * - `close` - Close the notification.
 * - `onClick` - The click event.
 * - `onShow` - The show event.
 * - `onError` - The error event.
 * - `onClose` - The close event.
 */
declare function notification(options?: WebNotificationOptions): {
    supported: svelte_store.Readable<boolean>;
    notify: svelte_store.Readable<Notification | null>;
    show: (overrides?: WebNotificationOptions) => Promise<Notification | undefined>;
    close: () => void;
    onClick: _sveu_shared_types_8a2f2352.t<any>;
    onShow: _sveu_shared_types_8a2f2352.t<any>;
    onError: _sveu_shared_types_8a2f2352.t<any>;
    onClose: _sveu_shared_types_8a2f2352.t<any>;
};

/**
 * Listens for a keyboard key being stroked.
 *
 * @param key - The key to listen for.
 * - `string` - The key to listen for. E.g. `"Shift"`.
 * - `string[]` - The keys to listen for. E.g. `["Shift", "Control"]`.
 * - `function` - A function that returns `true` if the key should be listened for.
 * - `true` - Listen for any key.
 *
 * @param handler - The handler to call when the key is stroked.
 *
 * @param options - The options.
 * - `target` - The target to listen on. Defaults to `window` in the browser and `undefined` in Node.js.
 * - `event` - The event to listen for. Defaults to `"keydown"`.
 * - `passive` - Whether the event listener is passive. Defaults to `false`.
 * - `dedupe` - To ignore repeated events when the key is being held down. Defaults to `false`.
 *
 * @returns A function to remove the event listener.
 */
declare function onKeyStroke(key: KeyFilter, handler: (event: KeyboardEvent) => void, options?: OnKeyStrokeOptions): () => void;
declare function onKeyStroke(handler: (event: KeyboardEvent) => void, options?: OnKeyStrokeOptions): () => void;

/**
 * Reactive Permissions API.
 *
 * @param name - The name of the permission.
 *
 * @param options - Options.
 * - `controls` - Whether to return controls or not.
 *
 * @example
 * ```ts
 * const state = permission("geolocation")
 *
 * const { state, query } = permission("geolocation", { controls: true })
 * ```
 *
 * @returns A reactive permission state.
 * - `state` - The current permission state.
 * - `supported` - Whether the permission is supported or not.
 * - `query` - A function that returns a promise that resolves to the permission status.
 *
 */
declare function permission(name: GeneralPermissionDescriptor["name"], options?: PermissionOptions<false>): PermissionReturn;
declare function permission(name: GeneralPermissionDescriptor["name"], options: PermissionOptions<true>): PermissionReturnWithControls;

/**
 * Reactive Navigator Languages.
 *
 * @example
 * ```ts
 * const state = preferredLang()
 * ```
 *
 * @returns Readable Store
 */
declare function preferredLang(): {
    subscribe: (this: void, run: svelte_store.Subscriber<readonly string[]>, invalidate?: svelte_store.Invalidator<readonly string[]> | undefined) => svelte_store.Unsubscriber;
};

type base64 = string;
/**
 * Push notification API
 *
 * @param swUrl - The service worker url
 *
 * @param vapid - The vapid key
 *
 * @param options - The options
 * - `base64` - Either to convert the push object into a base64 string. Default: `true`
 * - `userVisibleOnly` - Either to start subscribing, when the user is visible. Default: `true`
 *
 * @example
 * ```ts
 * const { result, supported } = pushNotification("/sw.js", "vapid_key")
 * ```
 *
 * @example
 * ```ts
 * const { result, supported } = pushNotification("/sw.js", "vapid_key", {
 * 	base64: false,
 * 	userVisibleOnly: false,
 * })
 * ```
 *
 *
 * @returns The push subscription
 * - `result` - The push subscription
 * - `supported` - Either the push notification is supported
 *
 */
declare function pushNotification(swUrl: string, vapid: base64, options?: PushOptions): {
    result: svelte_store.Readable<string | PushSubscription>;
    supported: svelte_store.Readable<boolean>;
};

/**
 * Call function on every `requestAnimationFrame` with controls.
 *
 * @param fn - Function to call on every `requestAnimationFrame`
 *
 * @param options - Options
 * - `immediate` - Start the requestAnimationFrame loop immediately on creation
 *
 * @example
 * ```ts
 * const { pause, resume, active } = rafFn(() => {
 * 	// do something
 * })
 * ```
 *
 * @returns Pauseable object.
 * - `pause` - Pause the requestAnimationFrame loop
 * - `resume` - Resume the requestAnimationFrame loop
 * - `active` - Readable store of the active state
 */
declare function rafFn(fn: Fn, options?: RafFnOptions): Pauseable;

/**
 * Observes changes to the dimensions of an Element's content or the border-box
 *
 * @param target - The target element to observe.
 *
 * @param callback - The callback function to invoke when the dimensions of the target element change.
 *
 * @param options - The options object. See https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/observe#parameters
 *
 * @example
 * ```ts
 * const { supported, cleanup } = resizeObserver(document.body, () => {
 * 	console.log("body dimensions changed")
 * })
 * ```
 *
 * @returns
 * - `supported` - Whether the browser supports the ResizeObserver API.
 * - `cleanup` - A function to cleanup the observer.
 *
 */
declare function resizeObserver(target: HTMLElement | SVGElement | undefined | null, callback: ResizeObserverCallback, options?: ResizeObserverOptions): {
    supported: svelte_store.Readable<boolean>;
    cleanup: () => void;
};

/**
 * Wrapper for around the ScreenOrientation API
 *
 * @example
 * ```ts
 * const { supported, orientation, angle, lock, unlock } = screenOrientation()
 * ```
 *
 * @returns
 * - `supported` - Whether the ScreenOrientation API is supported
 * - `orientation` - The current orientation of the device
 * - `angle` - The current angle of the device
 * - `lock` - Lock the orientation of the device
 * - `unlock` - Unlock the orientation of the device
 */
declare function screenOrientation(): {
    supported: svelte_store.Readable<boolean>;
    orientation: svelte_store.Readable<OrientationType>;
    angle: svelte_store.Readable<number>;
    lock: (type: OrientationLockType) => void;
    unlock: () => void;
};

/**
 * Reactively stores data in the browser's storage
 *
 * @param key - The key to store the data under
 *
 * @param fallback - The fallback value
 *
 * @param options - The options
 * - `store` - The store to use (local, session, cookie, url). Default: local
 * - `sync` - Whether to sync the data between tabs. Default: true
 * - `onError` - The function to call when an error occurs. Default: console.error
 * - `serializer` - The serializer to use.
 *
 *
 * @example
 * ```ts
 * const count = storage("count", 0)
 *
 * count.set(1)
 *
 * $count // 1
 * ```
 *
 * @example
 * ```ts
 * const count = storage("count", 0, { store: "session" })
 *
 * const count = storage("count", 0, { store: "cookie" })
 *
 * const count = storage("count", 0, { store: "url" })
 * ```
 *
 * @example
 * ```ts
 * const count = storage("count", 0, { sync: false })
 *
 * const count = storage("count", 0, { sync: false, store: "session" })
 * ```
 *
 * @example
 * ```ts
 * const count = storage("count", 0, { onError: console.log })
 *
 * const count = storage("count", 0, { onError: (e) => console.log(e) })
 * ```
 *
 * @example
 * ```ts
 * const count = storage("count", 0, { serializer: { read: (v) => v, write: (v) => v } })
 *
 * const count = storage("count", 0, { serializer: { read: (v) => v, write: (v) => v }, store: "session" })
 * ```
 *
 * @returns A watchable store
 */
declare function storage<T>(key: string, fallback: T, options?: StorageOptions<T>): Watchable<T>;

/**
 * Check if a feature is supported in the current browser.
 *
 * @param feature - The feature to check for.
 *
 * @param from - The object to check for the feature in.
 *
 * @example
 * ```ts
 * const supported = support("serviceWorker")
 * ```
 *
 * @example
 * ```ts
 * const supported = support("screen", "window")
 * ```
 *
 * @returns A readable store with the result.
 */
declare function support(feature: string, from?: "navigator" | "window" | "document" | "performance"): Readable<boolean>;

/**
 * Reactive URL query string
 *
 * @param mode - The mode to use for the URL query string
 * - `history` - Used when `history mode router` is used. Default
 * - `hash` - Used when `hash mode router` is used
 * - `hash-query` - Used when `history mode router` is used but , but want to use hash as query string
 *
 * @param options - The options to use for the URL query string
 * - `fallback` - The fallback value for the URL query string
 * - `removeNullish` - Whether to remove nullish values from the URL query string
 * - `removeFalsy` - Whether to remove falsy values from the URL query string
 * - `write` - Whether to write the URL query string to the URL
 * - `encode` - Whether to encode the URL query string
 *
 * @example
 * ```ts
 * const query = urlQuery()
 *
 * const query = urlQuery("hash")
 *
 * const query = urlQuery("hash-query")
 *
 * const query = urlQuery("history", {
 * 	fallback: {
 * 		foo: "bar",
 * 	},
 * 	removeNullish: true,
 * 	removeFalsy: true,
 * 	write: true,
 * 	encode: true,
 * })
 *
 * $query.foo = "barz"
 * ```
 *
 * @returns a watchable store
 */
declare function urlQuery<T extends Dict>(mode?: "history" | "hash" | "hash-query", options?: UrlQueryOptions<T>): Watchable<T>;

interface UserAgentDataBrand {
    name: string;
    version: string;
}
/**
 * Get user agent
 *
 * @remarks This function use the User-Agent Client Hints api. See https://developer.mozilla.org/en-US/docs/Web/API/NavigatorUAData
 *
 * @example
 * ```ts
 * const { supported, mobile, arch, model, platform, platformVersion, bitness, brands } = useragent()
 * ```
 * @returns
 * - `supported` - Whether the browser supports the User-Agent Client Hints api.
 * - `mobile` - Whether the device is a mobile device.
 * - `arch` - The architecture of the device.
 * - `model` - The model of the device.
 * - `platform` - The platform of the device.
 * - `platformVersion` - The platform version of the device.
 * - `bitness` - The bitness of the device.
 * - `brands` - The brands of the device.
 *
 */
declare function useragent(): {
    supported: svelte_store.Readable<boolean>;
    brands: svelte_store.Readable<UserAgentDataBrand[]>;
    mobile: svelte_store.Readable<boolean>;
    arch: svelte_store.Readable<string>;
    model: svelte_store.Readable<string>;
    platform: svelte_store.Readable<string>;
    platformVersion: svelte_store.Readable<string>;
    bitness: svelte_store.Readable<string>;
};

/**
 * Vibrate the device with a given pattern and duration
 *
 * @param options
 * - `pattern` - Vibration Pattern
 * - `interval` - Interval to run a persistent vibration, in seconds
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Vibration_API
 *
 * @example
 * ```ts
 * const { supported, intervalControls, start, stop } = vibrate({
 * 	pattern: [1, 2, 3],
 * 	interval: 5,
 * })
 * ```
 *
 * @returns
 * - `supported` - Whether the browser supports the Vibration API
 * - `intervalControls` - Controls for the persistent vibration
 * - `start` - Start the vibration
 * - `stop` - Stop the vibration
 */
declare function vibrate(options?: VibrateOptions): {
    supported: svelte_store.Readable<boolean>;
    intervalControls: Pauseable | undefined;
    start: () => void;
    stop: () => void;
};

/**
 * Reactive Screen Wake Lock API.
 *
 * @example
 * ```ts
 * const { supported, active, request, release } = wakeLock()
 * ```
 *
 * @returns
 * - `supported` - Whether the Wake Lock API is supported.
 * - `active` - Whether the Wake Lock is active.
 * - `request` - Request a Wake Lock.
 * - `release` - Release the Wake Lock.
 */
declare function wakeLock(): {
    supported: svelte_store.Readable<boolean>;
    active: svelte_store.Readable<boolean>;
    request: (type: WakeLockType) => Promise<void>;
    release: () => Promise<void>;
};

/**
 * Reactive WebSocket client.
 *
 * @param url - The websocket url.
 *
 * @param options - The websocket options.
 * - `onConnected` - The callback to be called when the websocket is connected.
 * - `onDisconnected` - The callback to be called when the websocket is disconnected.
 * - `onError` - The callback to be called when the websocket has an error.
 * - `onMessage` - The callback to be called when the websocket receives a message.
 * - `immediate` - Whether to connect to the websocket immediately. Default to `true`.
 * - `autoClose` - Whether to close the websocket connection when the websocket is disconnected. Default to `true`.
 * - `protocols` - The protocols to be used for the websocket connection. Default to `[]`.
 * - `heartbeat` - The heartbeat options. default to `false`.
 * - `heartbeat.message` - The message to be sent to the server for the heartbeat. Default to `ping`.
 * - `heartbeat.interval` - The interval in second to send the heartbeat message. Default to `1`.
 * - `heartbeat.timeout` - The timeout in second to wait for the pong message. Default to `1`.
 * - `autoReconnect` - Whether to automatically reconnect to the websocket server when the connection is closed. Default to `true`.
 * - `autoReconnect.retries` - The number of retries to reconnect to the websocket server. Default to `-1`.
 * - `autoReconnect.delay` - The delay in second before reconnecting to the websocket server. Default to `1`.
 * - `autoReconnect.onFailed` - The callback to be called On maximum retry times reached.
 *
 * @example
 * ```ts
 * const { data, status, ws, close, open, send } = websocket("ws://localhost:3000", {
 * 	onConnected: () => console.log("connected"),
 * 	onDisconnected: () => console.log("disconnected"),
 * 	onError: (e) => console.log(e),
 * 	onMessage: (data) => console.log(data),
 * 	immediate: true,
 * 	autoClose: true,
 * 	protocols: [],
 * 	heartbeat: {
 * 		message: "ping",
 * 		interval: 1,
 * 		timeout: 1,
 * 	},
 * 	autoReconnect: {
 * 		retries: -1,
 * 		delay: 1,
 * 		onFailed: () => console.log("failed"),
 * 	},
 * })
 * ```
 *
 * @example
 * ```ts
 * const { data, status, ws, close, open, send } = websocket("ws://localhost:3000", {
 * 	onConnected: () => console.log("connected"),
 * 	onDisconnected: () => console.log("disconnected"),
 * 	onError: (e) => console.log(e),
 * 	onMessage: (data) => console.log(data),
 * 	immediate: true,
 * 	autoClose: true,
 * 	protocols: [],
 * 	heartbeat: true,
 * 	autoReconnect: true,
 * })
 * ```
 *
 * @returns
 * - `data`: The data received from the websocket server.
 * - `status`: The current websocket status, can be only one of: 'OPEN', 'CONNECTING', 'CLOSED'
 * - `ws`: WebSocket instance.
 * - `close`: Closes the websocket connection gracefully.
 * - `open`: Reopen the websocket connection. If there the current one is active, will close it before opening a new one.
 * - `send`: Sends data through the websocket connection.
 */
declare function websocket<T>(url: string, options?: WebSocketOptions): {
    data: svelte_store.Readable<T | null>;
    status: svelte_store.Readable<WebSocketStatus>;
    ws: svelte_store.Readable<WebSocket | undefined>;
    close: (code?: number, reason?: string) => void;
    send: (data: string | ArrayBuffer | Blob, buffer?: boolean) => boolean;
    open: () => void;
};

/**
 * Reactively track window focus with `window.onfocus` and `window.onblur`.
 *
 * @example
 * ```ts
 * const winFocused = windowFocus()
 * ```
 *
 * @returns A readable store with the current window focus state.
 */
declare function windowFocus(): svelte_store.Readable<boolean>;

/**
 * Reactive window scroll.
 *
 * @example
 * ```ts
 * const { x, y } = windowScroll()
 * ```
 *
 * @returns
 * - `x`: A readable store with the current window scroll x position.
 * - `y`: A readable store with the current window scroll y position.
 */
declare function windowScroll(): {
    x: svelte_store.Readable<number>;
    y: svelte_store.Readable<number>;
};

/**
 * Reactive window size.
 *
 * @param options - Options
 * - `initialWidth` - The initial width of the window.
 * - `initialHeight` - The initial height of the window.
 * - `orientation` - Whether to use the `orientationchange`.
 * - `scrollbar` - Whether the scrollbar should be included in the width and height.
 *
 * @example
 * ```ts
 * const { width, height } = windowSize()
 * ```
 *
 * @example
 * ```ts
 * const { width, height } = windowSize({
 * 	initialWidth: 0,
 * 	initialHeight: 0,
 * 	orientation: true,
 * 	scrollbar: true,
 * })
 * ```
 *
 * @returns
 * - `width`: A readable store with the current window width.
 * - `height`: A readable store with the current window height.
 */
declare function windowSize(options?: WindowSizeOptions): {
    width: svelte_store.Readable<number>;
    height: svelte_store.Readable<number>;
};

/**
 * Simple Web Workers registration and communication.
 *
 * @param url - URL of the worker
 *
 * @param options - [WorkerOptions](https://developer.mozilla.org/en-US/docs/Web/API/Worker/Worker)
 *
 * @example
 * ```ts
 * const { data, error, wk, post, cleanup } = worker("worker.js")
 * ```
 *
 * @example
 * ```ts
 * const { data, error, wk, post, cleanup } = worker(() => new Worker("worker.js"))
 * ```
 *
 * @example
 * ```ts
 * const { data, error, wk, post, cleanup } = worker(new Worker("worker.js"))
 * ```
 *
 * @returns
 * - `data` - Data from the worker
 * - `error` - Error from the worker
 * - `wk` - Worker instance
 * - `post` - Function to send data to the worker
 * - `cleanup` - Function to terminate the worker
 */
declare function worker<T>(url: string, options?: WorkerOptions): WebWorkerReturn<T>;
/**
 * Simple Web Workers registration and communication.
 *
 * @param worker - Worker function or Worker instance
 *
 * @example
 * ```ts
 * const { data, error, wk, post, cleanup } = worker("worker.js")
 * ```
 *
 * @example
 * ```ts
 * const { data, error, wk, post, cleanup } = worker(() => new Worker("worker.js"))
 * ```
 *
 * @example
 * ```ts
 * const { data, error, wk, post, cleanup } = worker(new Worker("worker.js"))
 * ```
 *
 * @returns
 * - `data` - Data from the worker
 * - `error` - Error from the worker
 * - `wk` - Worker instance
 * - `post` - Function to send data to the worker
 * - `cleanup` - Function to terminate the worker
 */
declare function worker<T>(worker: Worker | WorkerFn): WebWorkerReturn<T>;

export { Base64ObjectOptions, Breakpoints, BroadcastChannelOptions, ClipboardOptions, ClipboardReturn, EyeDropper, EyeDropperOpenOptions, EyeDropperOptions, FaviconOptions, FileDialogOptions, FpsOptions, GeneralEventListener, GeneralPermissionDescriptor, GeolocationOptions, ImageOptions, InferEventTarget, IntersectionObserverOptions, KeyFilter, KeyPredicate, KeyStrokeEvents, ListAble, MemoryInfo, MemoryOptions, MouseOptions, MouseSourceType, NavigatorWithWakeLock, NetworkEffectiveType, NetworkType, OnKeyStrokeOptions, PerformanceMemory, PerformanceObserverOptions, PermissionOptions, PermissionReturn, PermissionReturnWithControls, Position, PushOptions, RafFnOptions, StorageOptions, StorageSerializer, ToDataURLOptions, UrlQueryOptions, UseMouseCoordType, UseMouseEventExtractor, UseMouseSourceType, VibrateOptions, WakeLockSentinel, WakeLockType, WebNotificationOptions, WebSocketOptions, WebSocketStatus, WebWorkerReturn, WindowSizeOptions, WorkerFn, activeEl, base64$1 as base64, breakpoints, broadcastChannel, clipboard, domVisible, eventDispatcher, eventListener, eyeDropper, fileDialog, fps, geolocation, image, intersectionObserver, mediaQuery, memory, mouse, mutationObserver, network, notification, eventListener as on, onKeyStroke, permission, preferredLang, pushNotification, rafFn, resizeObserver, screenOrientation, storage, support, urlQuery, useragent, vibrate, wakeLock, websocket, windowFocus, windowScroll, windowSize, worker };
