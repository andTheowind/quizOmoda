var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// src/activeEl/index.ts
import { browser as browser2, toWritable } from "@sveu/shared";

// src/eventListener/index.ts
import { browser, noop, on_destroy } from "@sveu/shared";
function eventListener(...args) {
  let target;
  let events;
  let listeners;
  let options;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    ;
    [events, listeners, options] = args;
    target = browser ? window : void 0;
  } else {
    ;
    [target, events, listeners, options] = args;
  }
  if (!target)
    return noop;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  function cleanup() {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  }
  function register(_target, event, listener, options2) {
    _target.addEventListener(event, listener, options2);
    return () => _target.removeEventListener(event, listener, options2);
  }
  cleanup();
  cleanups.push(
    ...events.flatMap((event) => {
      return listeners.map(
        (listener) => register(target, event, listener, options)
      );
    })
  );
  on_destroy(cleanup);
  return cleanup;
}

// src/activeEl/index.ts
function activeEl() {
  const { set, subscribe } = toWritable(
    browser2 ? document == null ? void 0 : document.activeElement : null
  );
  function handler() {
    set((document == null ? void 0 : document.activeElement) || null);
  }
  if (browser2) {
    eventListener(
      window,
      "blur",
      (event) => {
        if (event.relatedTarget !== null)
          return;
        handler();
      },
      true
    );
    eventListener(window, "focus", handler, true);
  }
  return { subscribe };
}

// src/base64/index.ts
import { browser as browser3, toReadable, toWritable as toWritable2 } from "@sveu/shared";
var DEFAULT_SERIALIZER = {
  array: (v) => JSON.stringify(v),
  object: (v) => JSON.stringify(v),
  set: (v) => JSON.stringify(Array.from(v)),
  map: (v) => JSON.stringify(Object.fromEntries(v)),
  null: () => ""
};
function get_serialization(target) {
  if (!target)
    return DEFAULT_SERIALIZER.null;
  if (target instanceof Map)
    return DEFAULT_SERIALIZER.map;
  else if (target instanceof Set)
    return DEFAULT_SERIALIZER.set;
  else if (Array.isArray(target))
    return DEFAULT_SERIALIZER.array;
  else
    return DEFAULT_SERIALIZER.object;
}
function img_loaded(img) {
  return new Promise((resolve, reject) => {
    if (!img.complete) {
      img.onload = () => {
        resolve();
      };
      img.onerror = reject;
    } else {
      resolve();
    }
  });
}
function blob_to_base64(blob) {
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = (e) => {
      var _a;
      resolve((_a = e.target) == null ? void 0 : _a.result);
    };
    fr.onerror = reject;
    fr.readAsDataURL(blob);
  });
}
function base64(target, options) {
  const base642 = toWritable2("");
  function execute() {
    if (!browser3)
      return;
    new Promise((resolve, reject) => {
      try {
        if (target == null)
          resolve("");
        else if (typeof target === "string") {
          resolve(
            blob_to_base64(
              new Blob([target], { type: "text/plain" })
            )
          );
        } else if (target instanceof Blob) {
          resolve(blob_to_base64(target));
        } else if (target instanceof ArrayBuffer) {
          resolve(
            window.btoa(
              String.fromCharCode(...new Uint8Array(target))
            )
          );
        } else if (target instanceof HTMLCanvasElement) {
          resolve(target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
        } else if (target instanceof HTMLImageElement) {
          const img = target.cloneNode(false);
          img.crossOrigin = "Anonymous";
          img_loaded(img).then(() => {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = img.width;
            canvas.height = img.height;
            ctx == null ? void 0 : ctx.drawImage(
              img,
              0,
              0,
              canvas.width,
              canvas.height
            );
            resolve(
              canvas.toDataURL(
                options == null ? void 0 : options.type,
                options == null ? void 0 : options.quality
              )
            );
          }).catch(reject);
        } else if (typeof target === "object") {
          const serializer = (options == null ? void 0 : options.serializer) || get_serialization(target);
          const serialized = serializer(target);
          return resolve(
            blob_to_base64(
              new Blob([serialized], {
                type: "application/json"
              })
            )
          );
        } else {
          reject(new Error("target is unsupported types"));
        }
      } catch (error) {
        reject(error);
      }
    }).then((res) => base642.set(res));
  }
  execute();
  return toReadable(base642);
}

// src/breakpoints/index.ts
import { adjustWithUnit, type, unstore as unstore2 } from "@sveu/shared";

// src/mediaQuery/index.ts
import { browser as browser5, toReadable as toReadable2, toWritable as toWritable4, unstore } from "@sveu/shared";

// src/support/index.ts
import { browser as browser4, toWritable as toWritable3 } from "@sveu/shared";
function support(feature, from = "navigator") {
  const { subscribe, set } = toWritable3(false);
  if (browser4) {
    const _from = from === "navigator" ? navigator : from === "window" ? window : from === "document" ? document : performance;
    set(_from && feature in _from);
  }
  return { subscribe };
}

// src/mediaQuery/index.ts
function mediaQuery(query) {
  if (!browser5)
    return toReadable2(false);
  const supported = support("matchMedia", "window");
  if (!unstore(supported))
    return toReadable2(false);
  const { subscribe, set } = toWritable4(false);
  const media_query = window.matchMedia(query);
  function handler(event) {
    set(event.matches);
  }
  set(media_query.matches);
  eventListener(media_query, "change", handler);
  return { subscribe };
}

// src/breakpoints/index.ts
function breakpoints(breakpoints2) {
  function get_value(key, delta) {
    let value = breakpoints2[key];
    if (delta != null)
      value = unstore2(adjustWithUnit(value, delta));
    if (type(value) === "number")
      value = `${value}px`;
    return value;
  }
  function gte(key) {
    return mediaQuery(`(min-width: ${get_value(key)})`);
  }
  function gt(key) {
    return mediaQuery(`(min-width: ${get_value(key, 0.1)})`);
  }
  function lte(key) {
    return mediaQuery(`(max-width: ${get_value(key)})`);
  }
  function lt(key) {
    return mediaQuery(`(max-width: ${get_value(key, -0.1)})`);
  }
  function bn(a, b) {
    return mediaQuery(
      `(min-width: ${get_value(a)}) and (max-width: ${get_value(
        b,
        -0.1
      )})`
    );
  }
  const shortcut_methods = Object.keys(breakpoints2).reduce((shortcuts, k) => {
    Object.defineProperty(shortcuts, k, {
      get: () => gte(k),
      enumerable: true,
      configurable: true
    });
    return shortcuts;
  }, {});
  return __spreadValues({
    gt,
    gte,
    lt,
    lte,
    bn
  }, shortcut_methods);
}

// src/broadcastChannel/index.ts
import {
  browser as browser6,
  on_destroy as on_destroy2,
  toReadable as toReadable3,
  toWritable as toWritable5,
  unstore as unstore3
} from "@sveu/shared";
function broadcastChannel(options = {}) {
  const { name = "default" } = options;
  const supported = support("BroadcastChannel", "window");
  const closed = toWritable5(false);
  const channel = toWritable5(void 0);
  const data = toWritable5(void 0);
  const error = toWritable5(null);
  function post(data2) {
    var _a;
    (_a = unstore3(channel)) == null ? void 0 : _a.postMessage(data2);
  }
  function close() {
    var _a;
    (_a = unstore3(channel)) == null ? void 0 : _a.close();
    closed.set(true);
  }
  if (unstore3(supported) && browser6) {
    error.set(null);
    channel.set(new BroadcastChannel(name));
    eventListener(
      unstore3(channel),
      "message",
      (event) => {
        data.set(event.data);
      },
      { passive: true }
    );
    eventListener(
      unstore3(channel),
      "messageerror",
      (event) => {
        error.set(event);
      },
      { passive: true }
    );
    eventListener(
      unstore3(channel),
      "close",
      () => {
        closed.set(true);
      },
      { passive: true }
    );
  }
  on_destroy2(close);
  return {
    channel: toReadable3(channel),
    closed: toReadable3(closed),
    data: toReadable3(data),
    error: toReadable3(error),
    supported,
    close,
    post
  };
}

// src/clipboard/index.ts
import { timeoutFn, toReadable as toReadable4, toWritable as toWritable6, unstore as unstore4 } from "@sveu/shared";
function clipboard(options = {}) {
  const { read = false, source, copiedDuring = 1.5, legacy = false } = options;
  const events = ["copy", "cut"];
  const clipboard_supported = support("clipboard");
  const supported = toReadable4(clipboard_supported || legacy);
  const text = toWritable6("");
  const copied = toWritable6(false);
  const timeout = timeoutFn(() => copied.set(false), copiedDuring, {
    immediate: false
  });
  async function update_text() {
    var _a;
    if (unstore4(clipboard_supported)) {
      const value = (_a = await (navigator == null ? void 0 : navigator.clipboard.readText())) != null ? _a : "";
      text.set(value);
    } else
      text.set(legacy_read());
  }
  if (unstore4(supported) && read) {
    for (const event of events)
      eventListener(event, update_text);
  }
  async function copy(value = source) {
    if (unstore4(supported) && value != null) {
      if (unstore4(clipboard_supported) && !legacy)
        await (navigator == null ? void 0 : navigator.clipboard.writeText(value));
      else
        legacy_copy(value);
      text.set(value);
      copied.set(true);
      timeout.resume();
    }
  }
  function legacy_copy(value) {
    const ta = document.createElement("textarea");
    ta.value = value != null ? value : "";
    ta.style.position = "absolute";
    ta.style.opacity = "0";
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    ta.remove();
  }
  function legacy_read() {
    var _a, _b, _c;
    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : "";
  }
  return {
    supported,
    text: toReadable4(text),
    copied: toReadable4(copied),
    copy
  };
}

// src/domVisible/index.ts
import { browser as browser7, toWritable as toWritable7 } from "@sveu/shared";
function domVisible() {
  if (!browser7)
    return toWritable7("hidden");
  const { subscribe, set } = toWritable7(
    document.visibilityState
  );
  function handler() {
    set(document.visibilityState);
  }
  eventListener(document, "visibilitychange", handler, true);
  return { subscribe };
}

// src/eventDispatcher/index.ts
function eventDispatcher(target) {
  function dispatch(name, value) {
    target == null ? void 0 : target.dispatchEvent(new CustomEvent(name, { detail: value }));
  }
  return dispatch;
}

// src/eyeDropper/index.ts
import { toReadable as toReadable5, toWritable as toWritable8, unstore as unstore5 } from "@sveu/shared";
function eyeDropper(options = {}) {
  const { fallback = "" } = options;
  const supported = support("EyeDropper", "window");
  const sRGBHex = toWritable8(fallback);
  async function open(openOptions) {
    if (!unstore5(supported))
      return;
    const eyeDropper2 = new window.EyeDropper();
    const result = await eyeDropper2.open(openOptions);
    sRGBHex.set(result.sRGBHex);
    return result;
  }
  return { supported, result: toReadable5(sRGBHex), open };
}

// src/fileDialog/index.ts
import { browser as browser8, createEventHook, toReadable as toReadable6, toWritable as toWritable9 } from "@sveu/shared";
import { contains } from "@sveu/shared/dicts";
var DEFAULT_OPTIONS = {
  multiple: true,
  accept: "*",
  reset: false
};
function fileDialog(options = {}) {
  const files = toWritable9(null);
  const accepted = toWritable9(null);
  const rejected = toWritable9(null);
  const { on: onChange, trigger } = createEventHook();
  let input;
  if (browser8) {
    input = document.createElement("input");
    input.type = "file";
    input.onchange = (event) => {
      const result = event.target;
      files.set(result.files);
      trigger(files);
      if (result.accept && result.files && result.accept !== "*") {
        const _accepted = Array.from(result.files).filter((file) => {
          const regex = new RegExp(result.accept.replace(/\*/g, ".*"));
          return regex.test(file.type);
        });
        const _rejected = Array.from(result.files).filter((file) => {
          const regex = new RegExp(result.accept.replace(/\*/g, ".*"));
          return !regex.test(file.type);
        });
        accepted.set(_accepted);
        rejected.set(_rejected);
      }
    };
  }
  function open(localOptions) {
    var _a, _b, _c;
    if (!input)
      return;
    const _options = __spreadValues(__spreadValues(__spreadValues({}, DEFAULT_OPTIONS), options), localOptions);
    input.multiple = (_a = _options.multiple) != null ? _a : true;
    input.accept = (_b = _options.accept) != null ? _b : "*";
    if (contains(_options, "capture"))
      input.capture = (_c = _options.capture) != null ? _c : "";
    if (_options.reset)
      reset();
    input.click();
  }
  function reset() {
    files.set(null);
    accepted.set(null);
    rejected.set(null);
    if (input)
      input.value = "";
  }
  return {
    files: toReadable6(files),
    accepted: toReadable6(accepted),
    rejected: toReadable6(rejected),
    open,
    reset,
    onChange
  };
}

// src/fps/index.ts
import { toWritable as toWritable11 } from "@sveu/shared";

// src/rafFn/index.ts
import {
  browser as browser9,
  on_destroy as on_destroy3,
  toReadable as toReadable7,
  toWritable as toWritable10,
  unstore as unstore6
} from "@sveu/shared";
function rafFn(fn, options = {}) {
  const { immediate = true } = options;
  const active = toWritable10(false);
  let raf_id = null;
  function loop() {
    if (!unstore6(active) || !browser9)
      return;
    fn();
    raf_id = window.requestAnimationFrame(loop);
  }
  function resume() {
    if (!unstore6(active) && browser9) {
      active.set(true);
      loop();
    }
  }
  function pause() {
    active.set(false);
    if (raf_id != null && window) {
      window.cancelAnimationFrame(raf_id);
      raf_id = null;
    }
  }
  if (immediate)
    resume();
  on_destroy3(pause);
  return {
    pause,
    resume,
    active: toReadable7(active)
  };
}

// src/fps/index.ts
function fps(options = {}) {
  var _a;
  const { subscribe, set } = toWritable11(0);
  if (typeof performance === "undefined")
    return { subscribe };
  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;
  let last = performance.now();
  let ticks = 0;
  rafFn(() => {
    ticks += 1;
    if (ticks >= every) {
      const now = performance.now();
      const diff = now - last;
      set(Math.round(1e3 / (diff / ticks)));
      last = now;
      ticks = 0;
    }
  });
  return { subscribe };
}

// src/geolocation/index.ts
import {
  browser as browser10,
  on_destroy as on_destroy4,
  toReadable as toReadable8,
  toWritable as toWritable12,
  unstore as unstore7
} from "@sveu/shared";
function geolocation(options = {}) {
  const { high = true, maxAge = 3, timeout = 27, immediate = true } = options;
  const supported = support("geolocation");
  const locatedAt = toWritable12(null);
  const error = toWritable12(null);
  const coords = toWritable12({
    accuracy: 0,
    latitude: Infinity,
    longitude: Infinity,
    altitude: null,
    altitudeAccuracy: null,
    heading: null,
    speed: null
  });
  function update(position) {
    locatedAt.set(position.timestamp);
    coords.set({
      accuracy: position.coords.accuracy,
      altitude: position.coords.altitude,
      altitudeAccuracy: position.coords.altitudeAccuracy,
      heading: position.coords.heading,
      latitude: position.coords.latitude,
      longitude: position.coords.longitude,
      speed: position.coords.speed
    });
    error.set(null);
  }
  let watcher;
  function resume() {
    if (unstore7(supported)) {
      watcher = navigator == null ? void 0 : navigator.geolocation.watchPosition(
        update,
        (err) => error.set(err),
        {
          enableHighAccuracy: high,
          maximumAge: maxAge * 1e3,
          timeout: timeout * 1e3
        }
      );
    }
  }
  if (immediate)
    resume();
  function pause() {
    if (watcher && browser10)
      navigator.geolocation.clearWatch(watcher);
  }
  on_destroy4(pause);
  return {
    supported,
    coords: toReadable8(coords),
    locatedAt: toReadable8(locatedAt),
    error: toReadable8(error),
    resume,
    pause
  };
}

// src/image/index.ts
import { asyncState } from "@sveu/shared";
async function load_image(options) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const {
      src,
      srcset,
      sizes,
      class: clazz,
      loading,
      crossOrigin,
      referrerPolicy
    } = options;
    img.src = src;
    if (srcset)
      img.srcset = srcset;
    if (sizes)
      img.sizes = sizes;
    if (clazz)
      img.className = clazz;
    if (loading)
      img.loading = loading;
    if (crossOrigin)
      img.crossOrigin = crossOrigin;
    if (referrerPolicy)
      img.referrerPolicy = referrerPolicy;
    img.onload = () => resolve(img);
    img.onerror = reject;
  });
}
function image(options, asyncStateOptions) {
  const state = asyncState(
    () => load_image(options),
    void 0,
    __spreadValues({
      resetOnExecute: true
    }, asyncStateOptions)
  );
  state.execute(asyncStateOptions ? asyncStateOptions.delay : 0);
  return state;
}

// src/intersectionObserver/index.ts
import { noop as noop2, on_destroy as on_destroy5, unstore as unstore8 } from "@sveu/shared";
function intersectionObserver(target, fn, options = {}) {
  const { root, margin = "0px", threshold = 0.1 } = options;
  const supported = support("IntersectionObserver", "window");
  let stop = noop2;
  if (unstore8(supported)) {
    if (!target)
      return;
    stop();
    const observer = new IntersectionObserver(fn, {
      root,
      rootMargin: margin,
      threshold
    });
    observer.observe(target);
    stop = () => {
      observer == null ? void 0 : observer.unobserve(target);
      observer == null ? void 0 : observer.disconnect();
    };
  }
  on_destroy5(stop);
  return {
    supported,
    stop
  };
}

// src/memory/index.ts
import { intervalFn, toReadable as toReadable9, toWritable as toWritable13, unstore as unstore9 } from "@sveu/shared";
function memory(options = {}) {
  const _memory = toWritable13(void 0);
  const supported = support("memory", "performance");
  if (unstore9(supported)) {
    const { interval = 1 } = options;
    intervalFn(
      () => {
        _memory.set({
          jsHeapSizeLimit: performance.memory.jsHeapSizeLimit,
          totalJSHeapSize: performance.memory.totalJSHeapSize,
          usedJSHeapSize: performance.memory.usedJSHeapSize
        });
      },
      interval,
      {
        immediate: options.immediate,
        immediateCallback: options.immediateCallback
      }
    );
  }
  return { supported, result: toReadable9(_memory) };
}

// src/mouse/index.ts
import { browser as browser11, toReadable as toReadable10, toWritable as toWritable14 } from "@sveu/shared";
var builtin_extractors = {
  page: (event) => [event.pageX, event.pageY],
  client: (event) => [event.clientX, event.clientY],
  screen: (event) => [event.screenX, event.screenY],
  movement: (event) => event instanceof Touch ? null : [event.movementX, event.movementY]
};
function mouse(options = {}) {
  const {
    type: type2 = "page",
    touch = true,
    resetOnTouchEnds = false,
    fallback = { x: 0, y: 0 },
    eventFilter
  } = options;
  const x = toWritable14(fallback.x);
  const y = toWritable14(fallback.y);
  const source_type = toWritable14(null);
  const extractor = typeof type2 === "function" ? type2 : builtin_extractors[type2];
  function mouse_handler(event) {
    const result = extractor(event);
    if (result) {
      x.set(result[0]);
      y.set(result[1]);
      source_type.set("mouse");
    }
  }
  function reset() {
    x.set(fallback.x);
    y.set(fallback.y);
  }
  function touch_handler(event) {
    if (event.touches.length > 0) {
      const result = extractor(event.touches[0]);
      if (result) {
        x.set(result[0]);
        y.set(result[1]);
        source_type.set("touch");
      }
    }
  }
  function mouse_handler_wrapper(event) {
    return eventFilter === void 0 ? mouse_handler(event) : eventFilter(() => mouse_handler(event), {});
  }
  function touch_handler_wrapper(event) {
    return eventFilter === void 0 ? touch_handler(event) : eventFilter(() => touch_handler(event), {});
  }
  if (browser11) {
    eventListener(window, "mousemove", mouse_handler_wrapper, {
      passive: true
    });
    eventListener(window, "dragover", mouse_handler_wrapper, {
      passive: true
    });
    if (touch && type2 !== "movement") {
      eventListener(window, "touchstart", touch_handler_wrapper, {
        passive: true
      });
      eventListener(window, "touchmove", touch_handler_wrapper, {
        passive: true
      });
      if (resetOnTouchEnds)
        eventListener(window, "touchend", reset, { passive: true });
    }
  }
  return {
    x: toReadable10(x),
    y: toReadable10(y),
    type: toReadable10(source_type)
  };
}

// src/mutationObserver/index.ts
import { on_destroy as on_destroy6, unstore as unstore10 } from "@sveu/shared";
function mutationObserver(target, fn, options = {}) {
  let observer;
  const supported = support("MutationObserver", "window");
  function cleanup() {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  }
  if (unstore10(supported) && target) {
    cleanup();
    observer = new MutationObserver(fn);
    observer.observe(target, options);
  }
  on_destroy6(cleanup);
  return {
    supported,
    cleanup
  };
}

// src/network/index.ts
import { browser as browser12, toReadable as toReadable11, toWritable as toWritable15, unstore as unstore11 } from "@sveu/shared";
function network() {
  const supported = support("connection");
  const online = toWritable15(true);
  const save_data = toWritable15(false);
  const offline_at = toWritable15(void 0);
  const online_at = toWritable15(void 0);
  const downlink = toWritable15(void 0);
  const downlink_max = toWritable15(void 0);
  const rtt = toWritable15(void 0);
  const effective_type = toWritable15(void 0);
  const type2 = toWritable15("unknown");
  function update_network_info() {
    online.set(navigator.onLine);
    offline_at.set(navigator.onLine ? void 0 : Date.now());
    online_at.set(navigator.onLine ? Date.now() : void 0);
    if (unstore11(supported)) {
      const connection = navigator.connection;
      downlink.set(connection.downlink);
      downlink_max.set(connection.downlinkMax);
      effective_type.set(connection.effectiveType);
      rtt.set(connection.rtt);
      save_data.set(connection.saveData);
      type2.set(connection.type);
    }
  }
  if (browser12) {
    eventListener(window, "offline", update_network_info);
    eventListener(window, "online", update_network_info);
  }
  if (unstore11(supported))
    eventListener(navigator.connection, "change", update_network_info, false);
  if (browser12)
    update_network_info();
  return {
    supported,
    online: toReadable11(online),
    saveData: toReadable11(save_data),
    offlineAt: toReadable11(offline_at),
    onlineAt: toReadable11(online_at),
    downlink: toReadable11(downlink),
    downlinkMax: toReadable11(downlink_max),
    effectiveType: toReadable11(effective_type),
    rtt: toReadable11(rtt),
    type: toReadable11(type2)
  };
}

// src/notification/index.ts
import {
  createEventHook as createEventHook2,
  on_destroy as on_destroy7,
  toReadable as toReadable12,
  toWritable as toWritable16,
  unstore as unstore12
} from "@sveu/shared";
function notification(options = {}) {
  const supported = support("Notification", "window");
  const notification2 = toWritable16(null);
  const on_click = createEventHook2();
  const on_show = createEventHook2();
  const on_error = createEventHook2();
  const on_close = createEventHook2();
  async function request_permission() {
    if (!unstore12(supported))
      return;
    if ("permission" in Notification && Notification.permission !== "denied")
      await Notification.requestPermission();
  }
  function close() {
    const n = unstore12(notification2);
    if (n)
      n.close();
    notification2.set(null);
  }
  async function show(overrides) {
    if (!unstore12(supported))
      return;
    await request_permission();
    const _options = Object.assign({}, options, overrides);
    notification2.set(new Notification(_options.title || "", _options));
    const n = unstore12(notification2);
    if (n) {
      n.onclick = (event) => on_click.trigger(event);
      n.onshow = (event) => on_show.trigger(event);
      n.onerror = (event) => on_error.trigger(event);
      n.onclose = (event) => on_close.trigger(event);
      return n;
    }
  }
  if (unstore12(supported)) {
    request_permission();
    eventListener(document, "visibilitychange", (e) => {
      e.preventDefault();
      if (document.visibilityState === "visible")
        close();
    });
  }
  on_destroy7(close);
  return {
    supported,
    notify: toReadable12(notification2),
    show,
    close,
    onClick: on_click.on,
    onShow: on_show.on,
    onError: on_error.on,
    onClose: on_close.on
  };
}

// src/onKeyStroke/index.ts
import { browser as browser13 } from "@sveu/shared";
function create_key_predicate(key_filter) {
  if (typeof key_filter === "function")
    return key_filter;
  if (typeof key_filter === "string")
    return (event) => event.key === key_filter;
  if (Array.isArray(key_filter))
    return (event) => key_filter.includes(event.key);
  return () => true;
}
function onKeyStroke(...args) {
  let key;
  let handler;
  let options = {};
  if (args.length === 3) {
    key = args[0];
    handler = args[1];
    options = args[2];
  } else if (args.length === 2) {
    if (typeof args[1] === "object") {
      key = true;
      handler = args[0];
      options = args[1];
    } else {
      key = args[0];
      handler = args[1];
    }
  } else {
    key = true;
    handler = args[0];
  }
  const {
    target = browser13 ? window : void 0,
    event = "keydown",
    passive = false,
    dedupe = false
  } = options;
  const predicate = create_key_predicate(key);
  const listener = (e) => {
    if (e.repeat && dedupe)
      return;
    if (predicate(e))
      handler(e);
  };
  return eventListener(target, event, listener, passive);
}

// src/permission/index.ts
import {
  createSingletonPromise,
  toReadable as toReadable13,
  toWritable as toWritable17,
  unstore as unstore13
} from "@sveu/shared";
function permission(name, options = {}) {
  const { controls = false } = options;
  const supported = support("permissions");
  let permission_status;
  const desc = { name };
  const state = toWritable17(void 0);
  const on_change = () => {
    if (permission_status)
      state.set(permission_status.state);
  };
  const query = createSingletonPromise(async () => {
    if (!unstore13(supported))
      return;
    if (!permission_status) {
      try {
        permission_status = await (navigator == null ? void 0 : navigator.permissions.query(desc));
        eventListener(permission_status, "change", on_change);
        on_change();
      } catch (e) {
        state.set("prompt");
      }
    }
    return permission_status;
  });
  query();
  if (controls) {
    return {
      state: toReadable13(state),
      supported,
      query
    };
  } else
    return toReadable13(state);
}

// src/preferredLang/index.ts
import { browser as browser14, toReadable as toReadable14, toWritable as toWritable18 } from "@sveu/shared";
function preferredLang() {
  if (!browser14)
    return toReadable14(["en"]);
  const navigator2 = window.navigator;
  const { subscribe, set } = toWritable18(
    navigator2.languages
  );
  eventListener(window, "languagechange", () => {
    set(navigator2.languages);
  });
  return { subscribe };
}

// src/pushNotification/index.ts
import { sleep, toReadable as toReadable15, toWritable as toWritable19, unstore as unstore14 } from "@sveu/shared";
function url_base64_to_uint8_array(base642) {
  const padding = "=".repeat((4 - base642.length % 4) % 4);
  const _base64 = (base642 + padding).replace(/-/g, "+").replace(/_/g, "/");
  const data = window.atob(_base64);
  const output = new Uint8Array(data.length);
  for (const [i, char] of data.split("").entries())
    output[i] = char.charCodeAt(0);
  return output;
}
function pushNotification(swUrl, vapid, options = {}) {
  const { base64: base642 = true, userVisibleOnly = true } = options;
  const supported = support("serviceWorker");
  const result = toWritable19("");
  async function init() {
    var _a, _b;
    const register = (_a = await navigator.serviceWorker.getRegistration(swUrl)) != null ? _a : await navigator.serviceWorker.register(swUrl);
    await sleep(0.1);
    const subscription = (_b = await register.pushManager.getSubscription()) != null ? _b : await register.pushManager.subscribe({
      userVisibleOnly,
      applicationServerKey: url_base64_to_uint8_array(vapid)
    });
    if (base642)
      result.set(window == null ? void 0 : window.btoa(JSON.stringify(subscription)));
    else
      result.set(subscription);
  }
  if (unstore14(supported))
    init();
  return { result: toReadable15(result), supported };
}

// src/resizeObserver/index.ts
import { on_destroy as on_destroy8, unstore as unstore15 } from "@sveu/shared";
function resizeObserver(target, callback, options = {}) {
  let observer;
  const supported = support("ResizeObserver", "window");
  function cleanup() {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  }
  cleanup();
  if (unstore15(supported) && target) {
    observer = new ResizeObserver(callback);
    observer == null ? void 0 : observer.observe(target, options);
  }
  on_destroy8(cleanup);
  return {
    supported,
    cleanup
  };
}

// src/screenOrientation/index.ts
import { toReadable as toReadable16, toWritable as toWritable20, unstore as unstore16 } from "@sveu/shared";
function screenOrientation() {
  var _a, _b, _c, _d;
  const supported_screen = support("screen", "window");
  const supported_orientation = unstore16(supported_screen) && "orientation" in window.screen;
  const supported = toReadable16(
    unstore16(supported_screen) && supported_orientation
  );
  const _screen_orientation = unstore16(supported) ? (_b = (_a = window == null ? void 0 : window.screen) == null ? void 0 : _a.orientation) != null ? _b : {} : {};
  const orientation = toWritable20(
    (_c = _screen_orientation == null ? void 0 : _screen_orientation.type) != null ? _c : "unknown"
  );
  const angle = toWritable20((_d = _screen_orientation == null ? void 0 : _screen_orientation.angle) != null ? _d : 0);
  if (unstore16(supported)) {
    eventListener(window, "orientationchange", () => {
      var _a2, _b2, _c2, _d2;
      orientation.set((_b2 = (_a2 = window == null ? void 0 : window.screen) == null ? void 0 : _a2.orientation) == null ? void 0 : _b2.type);
      angle.set((_d2 = (_c2 = window == null ? void 0 : window.screen) == null ? void 0 : _c2.orientation) == null ? void 0 : _d2.angle);
    });
  }
  function lock(type2) {
    if (!unstore16(supported))
      throw Error("The lock type is not supported");
    _screen_orientation == null ? void 0 : _screen_orientation.lock(type2);
  }
  function unlock() {
    if (unstore16(supported))
      _screen_orientation == null ? void 0 : _screen_orientation.unlock();
  }
  return {
    supported,
    orientation: toReadable16(orientation),
    angle: toReadable16(angle),
    lock,
    unlock
  };
}

// src/storage/index.ts
import { browser as browser16, noop as noop4, toNumber, unstore as unstore18, watchable as watchable2 } from "@sveu/shared";

// src/urlQuery/index.ts
import { browser as browser15, noop as noop3, unstore as unstore17, watchable } from "@sveu/shared";
function urlQuery(mode = "history", options = {}) {
  const {
    fallback = {},
    removeNullish = true,
    removeFalsy = false,
    write: enable_write = true,
    encode = false
  } = options;
  if (!browser15)
    return watchable(fallback, noop3);
  const state = watchable(fallback, (_, new_state) => {
    const queries = new URLSearchParams("");
    Object.keys(new_state).forEach((key) => {
      const item = new_state[key];
      if (Array.isArray(item) || typeof item === "object") {
        const serialized = JSON.stringify(item);
        queries.set(
          key,
          encode ? encodeURIComponent(serialized) : serialized
        );
      } else
        queries.set(key, item);
      if (removeFalsy && !item)
        queries.delete(key);
      if (removeNullish && item === null)
        queries.delete(key);
    });
    write(queries);
  });
  function get_raw_query() {
    if (mode === "history")
      return window.location.search || "";
    else if (mode === "hash") {
      const hash = window.location.hash || "";
      const index = hash.indexOf("?");
      return index > 0 ? hash.slice(index) : "";
    } else
      return (window.location.hash || "").replace(/^#/, "");
  }
  function construct_query(query) {
    const stringified = query.toString();
    if (mode === "history")
      return `${stringified ? `?${stringified}` : ""}${window.location.hash || ""}`;
    if (mode === "hash-query")
      return `${window.location.search || ""}${stringified ? `#${stringified}` : ""}`;
    const hash = window.location.hash || "#";
    const index = hash.indexOf("?");
    if (index > 0)
      return `${hash.slice(0, index)}${stringified ? `?${stringified}` : ""}`;
    return `${hash}${stringified ? `?${stringified}` : ""}`;
  }
  function read() {
    return new URLSearchParams(get_raw_query());
  }
  function update_state(queries) {
    const unused_keys = new Set(Object.keys(unstore17(state)));
    for (const key of queries.keys()) {
      const query_for_key = queries.getAll(key);
      const _state = unstore17(state);
      _state[key] = query_for_key.length > 1 ? query_for_key : queries.get(key) || "";
      unused_keys.delete(key);
    }
    Array.from(unused_keys).forEach((key) => delete unstore17(state)[key]);
  }
  function write(queries, should_update) {
    if (should_update)
      update_state(queries);
    window.history.replaceState(
      window.history.state,
      window.document.title,
      window.location.pathname + construct_query(queries)
    );
  }
  function on_changed() {
    if (!enable_write)
      return;
    write(read(), true);
  }
  eventListener(window, "popstate", on_changed, false);
  if (mode !== "history")
    eventListener(window, "hashchange", on_changed, false);
  const initial = read();
  if (initial.keys().next().value)
    update_state(initial);
  else
    Object.assign(state, fallback);
  return state;
}

// src/storage/index.ts
var storage_serializers = {
  boolean: {
    read: (v) => v === "true",
    write: (v) => String(v)
  },
  object: {
    read: (v) => JSON.parse(v),
    write: (v) => JSON.stringify(v)
  },
  number: {
    read: (v) => toNumber(v),
    write: (v) => String(v)
  },
  any: {
    read: (v) => v,
    write: (v) => String(v)
  },
  string: {
    read: (v) => v,
    write: (v) => String(v)
  },
  map: {
    read: (v) => new Map(JSON.parse(v)),
    write: (v) => JSON.stringify(Array.from(v.entries()))
  },
  set: {
    read: (v) => new Set(JSON.parse(v)),
    write: (v) => JSON.stringify(Array.from(v))
  },
  date: {
    read: (v) => new Date(v),
    write: (v) => v.toISOString()
  }
};
function guess_serializer_type(value) {
  return value == null ? "any" : value instanceof Set ? "set" : value instanceof Map ? "map" : value instanceof Date ? "date" : typeof value === "boolean" ? "boolean" : typeof value === "string" ? "string" : typeof value === "object" ? "object" : !Number.isNaN(value) ? "number" : "any";
}
function get_store(store) {
  if (store === "session")
    return {
      set(key, value) {
        sessionStorage.setItem(key, value);
      },
      get(key) {
        return sessionStorage.getItem(key);
      },
      delete(key) {
        sessionStorage.removeItem(key);
      }
    };
  if (store === "cookie")
    return {
      set(key, value) {
        document.cookie = `${key}=${value};path=/;`;
      },
      get(key) {
        const cookies = document.cookie.split(";");
        const cookie = cookies.find((cookie2) => cookie2.startsWith(key));
        if (!cookie)
          return null;
        return cookie.split("=")[1];
      },
      delete(key) {
        document.cookie = `${key}=; Max-Age=0; path=/;`;
      }
    };
  return {
    set(key, value) {
      localStorage.setItem(key, value);
    },
    get(key) {
      return localStorage.getItem(key);
    },
    delete(key) {
      localStorage.removeItem(key);
    }
  };
}
function storage(key, fallback, options = {}) {
  var _a, _b;
  const {
    store = "local",
    sync = true,
    onError = (e) => {
      console.error(e);
    }
  } = options;
  if (!browser16)
    return watchable2(fallback, noop4);
  if (store === "url") {
    const _fallback = {};
    _fallback[key] = fallback;
    const query = urlQuery("history", { fallback: _fallback });
    const data2 = watchable2(fallback, (_, n) => {
      if (!n)
        query.set("");
      else
        query.set({ [key]: n });
    });
    if (((_a = unstore18(query)) == null ? void 0 : _a[key]) !== void 0) {
      const item = unstore18(query)[key];
      try {
        if (typeof item === "string")
          data2.set(JSON.parse(item));
        else
          data2.set(item);
      } catch (e) {
        data2.set(item);
      }
    }
    return data2;
  }
  const type2 = guess_serializer_type(fallback);
  const serializer = (_b = options.serializer) != null ? _b : storage_serializers[type2];
  const data = watchable2(fallback, (_, n) => write(n));
  const _store = get_store(store);
  update();
  function read() {
    const value = _store.get(key);
    if (value === null) {
      if (fallback !== void 0 && fallback !== null)
        _store.set(key, serializer.write(fallback));
      return fallback;
    } else if (typeof value !== "string")
      return value;
    else
      return serializer.read(value);
  }
  function write(value) {
    try {
      if (value === null)
        _store.delete(key);
      else {
        const serialized = serializer.write(value);
        const old_value = _store.get(key);
        if (old_value !== serialized)
          _store == null ? void 0 : _store.set(key, serialized);
      }
    } catch (e) {
      onError(e);
    }
  }
  function update() {
    data.pause();
    try {
      data.set(read());
    } catch (e) {
      onError(e);
    } finally {
      data.resume();
    }
  }
  if (sync && store === "local")
    eventListener(window, "storage", update);
  return data;
}

// src/useragent/index.ts
import {
  asyncState as asyncState2,
  on_destroy as on_destroy9,
  toReadable as toReadable17,
  toWritable as toWritable21,
  unstore as unstore19
} from "@sveu/shared";
function useragent() {
  const mobile = toWritable21(false);
  const arch = toWritable21("");
  const model = toWritable21("");
  const platform = toWritable21("");
  const platformVersion = toWritable21("");
  const bitness = toWritable21("");
  const brands = toWritable21([{ name: "", version: "" }]);
  const supported = support("userAgentData");
  if (unstore19(supported)) {
    const { state } = asyncState2(
      // @ts-expect-error navigator.userAgentData is not supported in all browsers
      navigator.userAgentData.getHighEntropyValues([
        "architecture",
        "model",
        "platform",
        "platformVersion",
        "bitness"
      ]),
      {
        mobile: false,
        architecture: "",
        model: "",
        platform: "",
        platformVersion: "",
        bitness: "",
        brands: [{ name: "", version: "" }]
      }
    );
    const unsubscribe = state.subscribe((v) => {
      if (!v)
        return;
      mobile.set(v.mobile);
      arch.set(v.architecture);
      model.set(v.model);
      platform.set(v.platform);
      platformVersion.set(v.platformVersion);
      bitness.set(v.bitness);
      const _brands = v.brands.map((b) => {
        return {
          name: b.brand,
          version: b.version
        };
      });
      brands.set(_brands);
    });
    on_destroy9(unsubscribe);
  }
  return {
    supported,
    brands: toReadable17(brands),
    mobile: toReadable17(mobile),
    arch: toReadable17(arch),
    model: toReadable17(model),
    platform: toReadable17(platform),
    platformVersion: toReadable17(platformVersion),
    bitness: toReadable17(bitness)
  };
}

// src/vibrate/index.ts
import { intervalFn as intervalFn2, on_destroy as on_destroy10 } from "@sveu/shared";
function vibrate(options = {}) {
  const { pattern = [], interval = 0 } = options;
  const supported = support("vibrate");
  let intervalControls;
  function start() {
    if (supported) {
      if (Array.isArray(pattern)) {
        const new_pattern = pattern.map((num) => num * 1e3);
        navigator.vibrate(new_pattern);
      } else {
        navigator.vibrate(pattern * 1e3);
      }
    }
  }
  function stop() {
    if (supported)
      navigator.vibrate(0);
    intervalControls == null ? void 0 : intervalControls.pause();
  }
  if (interval > 0) {
    intervalControls = intervalFn2(start, interval, {
      immediate: false,
      immediateCallback: false
    });
  }
  on_destroy10(stop);
  return {
    supported,
    intervalControls,
    start,
    stop
  };
}

// src/wakeLock/index.ts
import { browser as browser17, toReadable as toReadable18, toWritable as toWritable22, unstore as unstore20 } from "@sveu/shared";
function wakeLock() {
  let _wake_lock;
  const supported = support("wakeLock");
  const active = toWritable22(false);
  async function on_visibility_change() {
    if (!unstore20(supported) || !_wake_lock)
      return;
    if (document.visibilityState === "visible")
      _wake_lock = await navigator.wakeLock.request("screen");
    active.set(!_wake_lock.released);
  }
  if (browser17)
    eventListener(document, "visibilitychange", on_visibility_change, {
      passive: true
    });
  async function request(type2) {
    if (!unstore20(supported))
      return;
    _wake_lock = await navigator.wakeLock.request(type2);
    active.set(!_wake_lock.released);
  }
  async function release() {
    if (!unstore20(supported) || !_wake_lock)
      return;
    await _wake_lock.release();
    active.set(!_wake_lock.released);
    _wake_lock = null;
  }
  return {
    supported,
    active: toReadable18(active),
    request,
    release
  };
}

// src/websocket/index.ts
import {
  browser as browser18,
  intervalFn as intervalFn3,
  isWs,
  on_destroy as on_destroy11,
  toReadable as toReadable19,
  toWritable as toWritable23,
  unstore as unstore21
} from "@sveu/shared";
var DEFAULT_PING_MESSAGE = "ping";
function resolve_nested_options(options) {
  if (options === true)
    return {};
  return options;
}
function websocket(url, options = {}) {
  const {
    onConnected,
    onDisconnected,
    onError,
    onMessage,
    immediate = true,
    autoClose = true,
    protocols = []
  } = options;
  const data = toWritable23(null);
  const status = toWritable23("CLOSED");
  const ws_store = toWritable23(void 0);
  let heartbeat_pause;
  let heartbeat_resume;
  let explicitly_closed = false;
  let retried = 0;
  let buffered_data = [];
  let pong_timeout_wait;
  function close(code = 1e3, reason) {
    var _a;
    if (!unstore21(ws_store))
      return;
    explicitly_closed = true;
    heartbeat_pause == null ? void 0 : heartbeat_pause();
    (_a = unstore21(ws_store)) == null ? void 0 : _a.close(code, reason);
  }
  function _send_buffer() {
    var _a;
    if ((buffered_data == null ? void 0 : buffered_data.length) && unstore21(ws_store) && unstore21(status) === "OPEN") {
      for (const buffer of buffered_data)
        (_a = unstore21(ws_store)) == null ? void 0 : _a.send(buffer);
      buffered_data = [];
    }
  }
  function reset_heartbeat() {
    clearTimeout(pong_timeout_wait);
    pong_timeout_wait = void 0;
  }
  function send(data2, buffer = true) {
    var _a;
    if (!unstore21(ws_store) || unstore21(status) !== "OPEN") {
      if (buffer)
        buffered_data = [...buffered_data, data2];
      return false;
    }
    _send_buffer();
    (_a = unstore21(ws_store)) == null ? void 0 : _a.send(data2);
    return true;
  }
  function _init() {
    if (explicitly_closed)
      return;
    const ws = new WebSocket(url, protocols);
    ws_store.set(ws);
    status.set("CONNECTING");
    ws.onopen = () => {
      status.set("OPEN");
      onConnected == null ? void 0 : onConnected(ws);
      heartbeat_resume == null ? void 0 : heartbeat_resume();
      _send_buffer();
    };
    ws.onclose = (event) => {
      status.set("CLOSED");
      ws_store.set(void 0);
      onDisconnected == null ? void 0 : onDisconnected(ws, event);
      if (!explicitly_closed && options.autoReconnect) {
        const {
          retries = -1,
          delay = 1,
          onFailed
        } = resolve_nested_options(options.autoReconnect);
        retried += 1;
        if (typeof retries === "number" && (retries < 0 || retried < retries))
          setTimeout(_init, delay * 1e3);
        else if (typeof retries === "function" && retries())
          setTimeout(_init, delay * 1e3);
        else
          onFailed == null ? void 0 : onFailed();
      }
    };
    ws.onerror = (event) => {
      onError == null ? void 0 : onError(ws, event);
    };
    ws.onmessage = (event) => {
      if (options.heartbeat) {
        reset_heartbeat();
        const { message = DEFAULT_PING_MESSAGE } = resolve_nested_options(options.heartbeat);
        if (event.data === message)
          return;
      }
      data.set(event.data);
      onMessage == null ? void 0 : onMessage(ws, event);
    };
  }
  if (options.heartbeat) {
    const {
      message = DEFAULT_PING_MESSAGE,
      interval = 1,
      pongTimeout = 1
    } = resolve_nested_options(options.heartbeat);
    const { pause, resume } = intervalFn3(
      () => {
        send(message, false);
        pong_timeout_wait = setTimeout(() => {
          close();
        }, pongTimeout * 1e3);
      },
      interval,
      { immediate: false }
    );
    heartbeat_pause = pause;
    heartbeat_resume = resume;
  }
  if (immediate && isWs)
    _init();
  if (autoClose) {
    if (browser18)
      eventListener(window, "beforeunload", () => close());
    on_destroy11(close);
  }
  function open() {
    close();
    explicitly_closed = false;
    retried = 0;
    _init();
  }
  return {
    data: toReadable19(data),
    status: toReadable19(status),
    ws: toReadable19(ws_store),
    close,
    send,
    open
  };
}

// src/windowFocus/index.ts
import { browser as browser19, toReadable as toReadable20, toWritable as toWritable24 } from "@sveu/shared";
function windowFocus() {
  if (!browser19)
    return toReadable20(false);
  const { set, subscribe } = toWritable24(window.document.hasFocus());
  eventListener(window, "blur", () => set(false));
  eventListener(window, "focus", () => set(true));
  return { subscribe };
}

// src/windowScroll/index.ts
import { browser as browser20, toReadable as toReadable21, toWritable as toWritable25 } from "@sveu/shared";
function windowScroll() {
  if (!browser20)
    return { x: toReadable21(0), y: toReadable21(0) };
  const x = toWritable25(window.scrollX);
  const y = toWritable25(window.scrollY);
  eventListener(
    window,
    "scroll",
    () => {
      x.set(window.scrollX);
      y.set(window.scrollY);
    },
    {
      capture: false,
      passive: true
    }
  );
  return { x: toReadable21(x), y: toReadable21(y) };
}

// src/windowSize/index.ts
import { browser as browser21, toReadable as toReadable22, toWritable as toWritable26 } from "@sveu/shared";
function windowSize(options = {}) {
  const {
    initialWidth = Infinity,
    initialHeight = Infinity,
    orientation = true,
    scrollbar = true
  } = options;
  if (!browser21)
    return { width: toReadable22(0), height: toReadable22(0) };
  const width = toWritable26(initialWidth);
  const height = toWritable26(initialHeight);
  const update = () => {
    if (scrollbar) {
      width.set(window.innerWidth);
      height.set(window.innerHeight);
    } else {
      width.set(window.document.documentElement.clientWidth);
      height.set(window.document.documentElement.clientHeight);
    }
  };
  update();
  eventListener("resize", update, { passive: true });
  if (orientation)
    eventListener("orientationchange", update, { passive: true });
  return { width, height };
}

// src/worker/index.ts
import {
  browser as browser22,
  noop as noop5,
  on_destroy as on_destroy12,
  toReadable as toReadable23,
  toWritable as toWritable27,
  unstore as unstore22
} from "@sveu/shared";
function worker(arg, options) {
  let unsubscribe = noop5;
  const data = toWritable27(null);
  const error = toWritable27(null);
  const wk = toWritable27(void 0);
  if (browser22) {
    if (typeof arg === "string")
      wk.set(new Worker(arg, options));
    else if (typeof arg === "function")
      wk.set(arg());
    else
      wk.set(arg);
    unsubscribe = wk.subscribe((_worker) => {
      if (!_worker)
        return;
      _worker.onmessage = (e) => {
        data.set(e.data);
      };
      _worker.onerror = (e) => {
        error.set(e.error);
      };
    });
  }
  function post(value) {
    const _wk = unstore22(wk);
    if (!_wk)
      return;
    _wk.postMessage(value);
  }
  function cleanup() {
    var _a;
    (_a = unstore22(wk)) == null ? void 0 : _a.terminate();
    unsubscribe();
  }
  on_destroy12(cleanup);
  return {
    data: toReadable23(data),
    error: toReadable23(error),
    wk: toReadable23(wk),
    post,
    cleanup
  };
}
export {
  activeEl,
  base64,
  breakpoints,
  broadcastChannel,
  clipboard,
  domVisible,
  eventDispatcher,
  eventListener,
  eyeDropper,
  fileDialog,
  fps,
  geolocation,
  image,
  intersectionObserver,
  mediaQuery,
  memory,
  mouse,
  mutationObserver,
  network,
  notification,
  eventListener as on,
  onKeyStroke,
  permission,
  preferredLang,
  pushNotification,
  rafFn,
  resizeObserver,
  screenOrientation,
  storage,
  support,
  urlQuery,
  useragent,
  vibrate,
  wakeLock,
  websocket,
  windowFocus,
  windowScroll,
  windowSize,
  worker
};
